#!/usr/bin/env bash
############################################################################
#
# MODULE:     	v.sort
# AUTHOR(S): 	Benjamin Ducke <benducke AT fastmail.fm>
# PURPOSE:		Sorts features of a vector map on values of a chosen field.
#				This script takes a vector map as input and creates a new vector map
#				in which the data storage order confirms to user-defined criteria.
#             	At the same time, this script ensures that all primary keys of the
#				new vector map are stored as an unbroken sequence "1,2,3,..,n".
#				Thus, v.sort can be used to "fix" GRASS vector maps that have "messy"
#				primary key sequences or to enforce a specific data order on vector
#				maps.
#
# COMPATIBILITY:
#				This script has been written to run under GRASS 8 (and possibly
#				any later version that retains the GRASS 8 syntax for the GRASS
#				commands called by this script).
#
# COPYRIGHT:    (C) 2024 by Benjamin Ducke
#
#               This program is free software under the GNU General Public
#               License (>=v2). Read the file COPYING that comes with GRASS
#               for details.
#
#############################################################################

# CAVEATS/TODO/LIMITATIONS
# * This script makes heavy use of direct SQL execution. 
#	It will only run if the current GRASS session is using one of the supported DBMS backends.
#

#
# REQUIRED EXTERNAL PROGRAMS:
# - grep
# - echo (on Windows)
# - expr
# - date
# - cut
# - sort
# - wc
#


# %Module
# % description: Sorts features of a vector map on values of a chosen field.
# % keywords: vector, attributes, sorting, ordering
# %End

# %Flag
# %  key: e
# %  description: Empty field values allowed
# %End

# %Flag
# %  key: i
# %  description: Ignore leading blanks in field values
# %End

# %Flag
# %  key: n
# %  description: Numeric sorting (forced)
# %End

# %Flag
# %  key: p
# %  description: Print known and supported DBMS (then quit)
# %End

# %Flag
# %  key: u
# %  description: Unique field values required
# %End

# %Option
# % key: input
# % type: string
# % required: yes
# % multiple: no
# % key_desc: name
# % description: Input vector map
# % gisprompt: old,vector,vector
# %End

# %option G_OPT_V_FIELD
# % key: layer
# %end

# %Option
# % key: output
# % type: string
# % required: yes
# % multiple: no
# % key_desc: name
# % description: Sorted output vector map
# % gisprompt: new,vector,vector
# %End

# %option G_OPT_DB_COLUMN
# % key: by
# % required: no
# % description: Input map's attribute table column by which to sort (default: primary key)
# % gisprompt: old,dbcolumn,dbcolumn
# %end

# %Option
# % key: order
# % type: string
# % required: no
# % multiple: no
# % key_desc: value
# % options: asc,desc
# % description: Sort order
# % answer: asc
# %End

# %Option
# % key: sqlbuflen
# % type: integer
# % required: no
# % multiple: no
# % key_desc: value
# % answer: 20
# % description: Number of SQL statements to buffer (performance)
# %End

# %Option
# % key: delimiter
# % type: string
# % required: no
# % multiple: no
# % key_desc: name
# % description: Delimiter for text field parsing (change in case of errors)
# % answer: |
# %End


# System setup: Modify if needed.
if [ -n "${MSYSPATH}" ] ; then
	# "MSYSPATH" was set by the Windows ".bat" script that called
	# this script. It contains the path to the "bin" folder of
	# the local MSYS(2) installation, using Linux style "/" separators
	# but NOT INCLUDING the final path separator, like so:
	# "/c/msys64/usr/bin"
	# That means we are running under MS Windows,
	# and we must make some adjustments to external program calls!
	CUT="${MSYSPATH}/cut.exe"
	DATE="${MSYSPATH}/date.exe"
	ECHO="${MSYSPATH}/echo.exe"	
	EXPR="${MSYSPATH}/expr.exe"	
	GREP="${MSYSPATH}/grep.exe"
	SORT="${MSYSPATH}/sort.exe"
	WC="${MSYSPATH}/wc.exe"
	# Scripted GRASS commands require ".bat" extensions for Windows, or else "sh.exe" won't find them!
	V_DB_ADDCOLUMN="v.db.addcolumn.bat"
	V_DB_ADDTABLE="v.db.addtable.bat"
	# Set filter for line endings for this system:
	IFS_NEWLINE=$'\r\n\b'
else
	CUT="cut"
	DATE="date"
	ECHO="echo"
	EXPR="expr"
	GREP="grep"	
	SORT="sort"
	WC="wc"
	# These are the GRASS commands that are actually Shell/Python scripts.
	# On Linux/macOS they are executed through the shell, just like binaries.
	V_DB_ADDCOLUMN="v.db.addcolumn"
	V_DB_ADDTABLE="v.db.addtable"
	# Set filter for line endings for this system:
	IFS_NEWLINE=$'\n\b'
fi

# Minimal Bash version for expected to run this script without errors.
BASH_VERSION_MIN="3" # Version 3 is the latest one shipped on macOS!

# Keep a copy of IFS, as it was set before running this script!
IFS_ORIGINAL="$IFS"

# Basic module setup.
MODULE_NAME="v_sort" # for prefixing temporary object names
MODULE_NAME_EXEC="v.sort" # name as run on the command line
MODULE_VERSION="1.1.0b1"

# Exit status variables.
EXIT_OK=0
EXIT_CTRL_C=1
EXIT_TERMINATED=2
EXIT_ERROR=3

# DBMS backend idiosyncracies
DBMS_LOCKS_REQUIRED=0   # DBMS locking off (will be set later, as required)
DBMS_THREAD_SAFE=0		# Indicates whether the DBMS is thread safe (in the context of this script)
DBMS_INDEX_SUPPORTED=0  # Indicates whether the DBMS supports building an index.
DBMS_PRESERVES_ORDER=0  # Indicates whether the DBMS preserves order of record insertion reliably.
DBMS_FILE_PATH=0		# Indicates whether the DBMS driver uses a file path to specify the location of a database.
DBMS_IDENT_QUOTE='"'	# Quoting character for field/table names that (might) contain spaces
DBMS_BEGIN="BEGIN;"		# Opening statement for an SQL transction; most DBMS should understand "BEGIN;"
DBMS_COMMIT="COMMIT;";	# Closing statement for an SQL transction; most DBMS should understand "COMMIT;"

# List of fully supported DBMS (GRASS driver names):
DBMS_SUPPORT_LIST="mesql,mysql,sqlite"

# Basic sanity checks.
if [ -z "$GISBASE" ] ; then
    "${ECHO}" "ERROR: You must be in GRASS GIS to run this program." 1>&2
    exit ${EXIT_ERROR}
fi

if [ "$1" != "@ARGS_PARSED@" ] ; then
    exec g.parser "$0" "$@"
fi

# Check if we are running under old GRASS 6
GRASS_V6=`g.version -e | "${GREP}" "GRASS 6"`

# Check if we are running under old GRASS 7
GRASS_V7=`g.version -e | "${GREP}" "GRASS 7"`

# Check if we are running under old GRASS 8
GRASS_V8=`g.version -e | "${GREP}" "GRASS 8"`

if [ -n "$GRASS_V6" ] ; then
	g.message -e "This script requires GRASS GIS version 7 or higher."
	exit ${EXIT_ERROR}
fi

# Create prefix for all temporary maps
TMP_PREFIX="tmp_${MODULE_NAME}_`"${ECHO}" $$`_d"

# Names of temporary maps (VECTOR)
TMP_VECT_EXTRACT="${TMP_PREFIX}_v_extract" 				# Feature(s) extracted from input vector map


# FUNCTION
# clean_up: Remove temporary maps, reset region to what it was, etc.
clean_up () {
	
	g.message -i "Cleaning up..."
	
	# Feature(s) extracted from input vector map.
	type="vector"
	elem="${TMP_VECT_EXTRACT}"
	found=`g.list type="${type}" | "${GREP}" -c "${elem}"`
	if [ $found -gt 0 ] ; then
		g.remove type="${type}" name="${elem}" -f --q 2>/dev/null
	fi
}
	

# Make sure we get to clean up!
trap "g.message -i 'Terminated by user (CTRL+C).' ; clean_up ; exit ${EXIT_CTRL_C}" 2 # user interrupt (CTRL+C)


# FUNCTION
# check_error: Check last return status, issue an error message and abort if appropriate.
#
# Arguments:
#
# $1 - Error message to display (mandatory)
# $2 - PID (optional)
#
# At least $1 must be provided (error message) for this function to
# work correctly.
#
# If $2 is also provided, then its value will be interpreted as
# an integer type PID, and a 'kill' command with Signal type '1'
# will be issued to terminate the corresponding job.
#
check_error () {
	if [ ! "$?" -eq "0" ] ; then
		g.message -e "$1"
		if [ -n "${PKILL}" ] && [ -n $2 ] && [ "$2" != "" ] ; then
			# PID passed and "pkill" command available: kill this and all
			# subprocesses!
			clean_up
			g.message -e "Terminating job with PID $2 and all subprocesses."	
			"${PKILL}" --signal 9 -P $2 &
			exit ${EXIT_ERROR}
		else
			clean_up
			exit ${EXIT_ERROR}
		fi		
	fi
}


# FUNCTION
# check_warn: Check last return status, issue a warning message if appropriate.
check_warn () {
	if [ ! "$?" -eq "0" ] ; then
		g.message -w "$1"
	fi
}


# FUNCTION
# exit_error: Display an error message and exit with default error code.
# 
# Arguments:
#
# $1 - Error message to display (mandatory)
# $2 - PID (optional)
#
# At least $1 must be provided (error message) for this function to
# work correctly.
#
# If $2 is also provided, then its value will be interpreted as
# an integer type PID, and a 'kill' command with Signal type '1'
# will be issued to terminate the corresponding job.
#
exit_error () {
	g.message -e "$1"	
	if [ -n $2 ] && [ "$2" != "" ] ; then
	    # PID passed: kill!
	    # Note: The trap set at the beginning of this script will make
	    # sure that all clean-up functions are run.
	    g.message -e "Terminating job with PID $2."
		#kill -s 1 $2
		clean_up
		exit ${EXIT_ERROR}
	else
		clean_up
		exit ${EXIT_ERROR}
	fi	
}


# FUNCTION
# eval_ws_safe:  White-space resilient setting of variables from command output.
#                This is useful for many GRASS commands that produce shell style
#				  output (like 'g.region -pg') of the form:
#                   var1=abc
#                   var2=123
#                   ...
#                Pass string with a command's full output as $1.
#                Pass name of a variable to set from output as $2.
#                This function will then grep the _first_ occurrence
#                of the variable name (case sensitive!) from the command output
#                and set it to the value following "=" (equal sign).
#				  As opposed to a simple 'eval', this function is able
#                to correctly set variable values that contain whitespace!
#				  This is also the safer option to use if an 'eval' statement would
#                potentially encounter values with white space for variables other
#			 	  than the target variable.
#                The contents for setting the variable are returned in "EVAL_RESULT".
eval_ws_safe () {
	OLD_IFS_EVAL_WS_SAFE="$IFS"
	# Set list separator to newline and line break characters:
	IFS="${IFS_NEWLINE}"
	# Process (list of) input line(s):
	str=`${ECHO} "$1" | "${GREP}" "$2="`
	for i in $str
	do
		IFS="="
		CUR=$i
		for j in $CUR				
		do			
			EVAL_RESULT="$j"			
		done
	done
	IFS="$OLD_IFS_EVAL_WS_SAFE"
}


# FUNCTION
# get_tbl_info: Retrieves essential information for first attribute table's DB connection
#				("layer 1") connected to a GRASS vector map. The information is read from
#				the output of 'v.info'.
#
#            	This function reads two arguments:
#					$1 -- name of GRASS vector map that has the attibute table of interest
#					$2 -- layer number of $1
#
#				($2 may be skipped, in which case the default layer is "1")
#
#            	This function sets three variables:
#               	attribute_database_driver = GRASS database driver used for the connection
#												(same as used/listed by 'db.connect')
#					attribute_database = the name of the actual DB that stores the table
#					attribute_table = the name of the linked attribute table in the DB
#
#				 It will abort the program if there is a problem with the map and/or its table.            
#
get_tbl_info () {
	if [ -n "${2}" ] ; then
		cmd=`v.info -e map="${1}" layer="${2}"`
	else
		cmd=`v.info -e map="${1}" layer="1"`
	fi
	check_error "Failed to query vector map '$1' for extended metadata."
	
	# Get DB driver name:
	eval_ws_safe "${cmd}" "attribute_database_driver"
	if [ -z "${EVAL_RESULT}" ] ; then
		exit_error "Failed to retrieve driver of database connection for vector map '1'."
	fi
	attribute_database_driver="${EVAL_RESULT}"
	
	# Get name of connected database:
	eval_ws_safe "${cmd}" "attribute_database"
	if [ -z "${EVAL_RESULT}" ] ; then
		exit_error "Failed to retrieve name of database connection for vector map '$1'."
	fi
	attribute_database="${EVAL_RESULT}"
	
	# Get name of linked table in conntected DB:
	eval_ws_safe "${cmd}" "attribute_table"
	if [ -z "${EVAL_RESULT}" ] ; then
		exit_error "Failed to retrieve name of database table for vector map '1'."
	fi
	attribute_table="${EVAL_RESULT}"
}


# FUNCTION
# check_setup: Check system setup (required external programs available?).
check_setup () {	
	
	message="Required program not found or not working as expected: "
	
	# Echo (test first, since the following require a working echo command!)
	prg="${ECHO}"
	result=`"${ECHO}" "1 2 4 3"`
	if [ "$result" != "1 2 4 3" ] ; then
		exit_error "$message ${prg}"
	fi
	
	# The following commands are only tested if they have been defined!
	
	# Awk	
	prg="${AWK}"
	if [ -n "${prg}" ] ; then
		result=`"${ECHO}" "1 2 4 3" | ${prg} '{ print $3 }'`
		if [ $result -ne 4 ] ; then
			exit_error "$message ${prg}"
		fi
	fi
	
	# Cut
	prg="${CUT}"
	if [ -n "${prg}" ] ; then
		result=`"${ECHO}" "1,2,4,3" | ${prg} -f3 -d,`
		if [ $result -ne 4 ] ; then
			exit_error "$message ${prg}"
		fi
	fi
	
	# Date
	prg="${DATE}"
	if [ -n "${prg}" ] ; then
		: $(${prg} -u)
		check_error "${message} '${prg}'."
	fi
	
	# Expr
	prg="${EXPR}"
	if [ -n "${prg}" ] ; then
		result=`${prg} 1 + 3`
		if [ $result -ne 4 ] ; then
			exit_error "$message ${prg}"
		fi
	fi
	
	# Grep
	prg="${GREP}"
	if [ -n "${prg}" ] ; then
		result=`"${ECHO}" "1 2 3 4" | ${prg} "3 4" -c`
		if [ $result -ne 1 ] ; then
			exit_error "$message ${prg}"
		fi
	fi
	
	# Check for multi-threading support.
	# Pkill, Sleep, Wait: Multi-threading support
	if [ -z "${PKILL}" ] || [ -z "${WAIT}" ] || [ -z "${SLEEP}" ] ; then
		# If any of these commands ire missing then we are running on a system (likely Windows)
		# that does not have what it takes for concurrent execution of shell scripts.
		MULTI_THREADING_SUPPORT=
	else
		# In the other case, all three of pkill, wait and sleep must be present!
		#
		# We have pkill command: Let's check that it works!
		# TODO: There seems to be no portable AND safe way of checking
		#       that pkill works. For now, we just trust that it's there
		#		if $PKILL is declared!
		#prg="${PKILL}"
		#: $(${prg} --help)
		#check_error "${message} '${prg}'."
		# We have sleep command: Let's check that it works!
		prg="${SLEEP}"
		: $(${prg} 0.1)
		check_error "${message} '${prg}'."
		# We have wait command: Let's check that it works!
		prg="${WAIT}"
		: $(${prg})
		check_error "${message} '${prg}'."
		# Support for multi-threading exists!
		MULTI_THREADING_SUPPORT="y"
	fi
	
	# Sort
	prg="${SORT}"
	if [ -n "${prg}" ] ; then
		result=`"${ECHO}" "Just one line." | ${prg}`
		check_error "${message} '${prg}'."
	fi
	
	# Wc
	prg="${WC}"
	if [ -n "${prg}" ] ; then	
		result=`"${ECHO}" "one two five" | ${prg} -w`
		if [ $result -ne 3 ] ; then
			exit_error "$message ${prg}"
		fi
	fi
	
}


# FUNCTION
# get_interpreter: 		Runs a lot of code in an attempt to accurately determine
#						the interpreter that is currently running this script.
#						It is not guaranteed that the interpreter is the same as
#						the login shell or user default shell. Thus, reading typical
#						environment variables is pretty pointless.
#						The code in this function has been taken from:
#						
#						https://www.in-ulm.de/~mascheck/various/whatshell/
#
#						Originally, it was designed to echo the name of the running
#						interpreter to the terminal.
#
#						Within this script it is used to read the interpreter's name
#						into a variable for further analysis:
#
#						interpreter=`get_interpreter`
#						
get_interpreter () {
'echo' +"'\
@ goto dos \
[exit[if {[lsearch -exact [package names] Expect]>=0} {puts expect\ [\
package require Expect]\ (Tcl\ [info patchlevel])} elseif {[lsearch -exact [\
package names] Tk]>=0} {puts wish\ (Tcl\ [info patchlevel],\ Tk\ [package \
require Tk])} else {puts tcl\ [info patchlevel]}]]' >/dev/null ' {\">/dev/null \
">"/dev/null" +"\'";q='''=.q,';q=%[\"
echo ">/dev/null;status=0;@ {status=1};*=(" '$' ");~ $status 1&&{e='"\
"';eval catch $2 ^'&version {eval ''echo <='^ $2 ^'&version''}';exit};e='"\
"';if (eval '{let ''a^~a''} >[2] /dev/null'){e='"\
"';exec echo akanga};eval exec echo rc $2 ^ version;\" > /dev/null
: #;echo possibly pre-Bourne UNIX V1-6 shell;exit
if { bindkey >& /dev/null } then
exec echo $version
else
exec echo csh
endif
: dos
@echo off
cls
echo %OS% %COMSPEC%
goto fin
", unless eval 'printf "perl %vd\n",$^V;exit;'> "/dev/null";eval ': "\'';
=S"'
: 'This script aims at recognizing all Bourne compatible shells.
   Emphasis is on shells without any version variables.
   Please comment to mascheck@in-ulm.de'
: '$Id: whatshell.sh,v 1.26 2018/02/18 23:38:06 xmascheck Exp xmascheck $'
: 'fixes are tracked on www.in-ulm.de/~mascheck/various/whatshell/'

LC_ALL=C; export LC_ALL
: 'trivial cases first, yet parseable for historic shells'
case $BASH_VERSION in *.*) { echo "bash $BASH_VERSION";exit;};;esac
case $ZSH_VERSION  in *.*) { echo "zsh $ZSH_VERSION";exit;};;esac
case "$VERSION" in *zsh*) { echo "$VERSION";exit;};;esac
case  "$SH_VERSION" in *PD*) { echo "$SH_VERSION";exit;};;esac
case "$KSH_VERSION" in *PD*|*MIRBSD*) { echo "$KSH_VERSION";exit;};;esac
case "$POSH_VERSION" in 0.[1234]|0.[1234].*) \
     { echo "posh $POSH_VERSION, possibly slightly newer, yet<0.5";exit;}
  ;; *.*|*POSH*) { echo "posh $POSH_VERSION";exit;};; esac
case $YASH_VERSION in *.*) { echo "yash $YASH_VERSION";exit;};;esac

: 'traditional Bourne shell'
(eval ': $(:)') 2>/dev/null || {
  case `(:^times) 2>&1` in *0m*):;;
    *)p=' (and pipe check for Bourne shell failed)';;esac
  : 'pre-SVR2: no functions, no echo built-in.'
  (eval 'f(){ echo :; };f') >/dev/null 2>&1 || {
    ( eval '# :' ) 2>/dev/null || { echo '7th edition Bourne shell'"$p";exit;}
    ( : ${var:=value} ) 2>/dev/null ||
    { echo '7th edition Bourne shell, # comments (BSD, or port)'"$p";exit;}
    set x x; shift 2;test "$#" != 0 && { echo 'System III Bourne shell'"$p";exit;}
    { echo 'SVR1 Bourne shell'"$p";exit;}
  }
}; : 'keep syntactical block small for pre-SVR2'

myex(){ echo "$@";exit;} # "exec echo" might call the external command

(eval ': $(:)') 2>/dev/null || {
  (set -m; set +m) 2>/dev/null && {
    priv=0;(priv work)>/dev/null 2>&1 &&
      case `(priv work)2>&1` in *built*|*found*) priv=1;;esac
    read_r=0;(echo|read -r dummy 2>/dev/null) && read_r=1
    a_read=0;unset var;set -a;read var <&-;case `export` in
       *var*) a_read=1;;esac
    case_in=0;(eval 'case x in in) :;;esac')2>/dev/null && case_in=1
    ux=0;a=`(notexistent_cmd) 2>&1`; case $a in *UX*) ux=1;;esac
    case $priv$ux$read_r$a_read$case_in in
       11110) myex 'SVR4.2 MP2 Bourne shell'
    ;; 11010) myex 'SVR4.2 Bourne shell'
    ;; 10010|01010) myex 'SVR4.x Bourne shell (between 4.0 and 4.2)'
    ;; 00111) myex 'SVR4 Bourne shell (SunOS 5 schily variant, before 2016-02-02)'
    ;; 00101) myex 'SVR4 Bourne shell (SunOS 5 heirloom variant)'
    ;; 00001) myex 'SVR4 Bourne shell (SunOS 5 variant)'
    ;; 00000) myex 'SVR4.0 Bourne shell'
    ;; *)     myex 'unknown SVR4 Bourne shell variant' ;;esac
  }
  r=0; case `(read) 2>&1` in *"missing arguments"*) r=1;;esac
  g=0; (set -- -x; getopts x var) 2>/dev/null && g=1
  case $r$g in
     11) myex 'SVR3 Bourne shell'
  ;; 10) myex 'SVR3 Bourne shell (but getopts built-in is missing)'
  ;; 01) myex 'SVR3 Bourne shell (but read built-in does not match)'
  ;; 00) (builtin :) >/dev/null 2>&1 &&
 	myex '8th edition (SVR2) Bourne shell'"$p"
 	(type :) >/dev/null 2>&1 && myex 'SVR2 Bourne shell'"$p" ||
 	myex 'SVR2 shell (but type built-in is missing)'"$p"
  ;;esac
}

case $( (:^times) 2>&1) in *0m*)
  case `eval '(echo $((1+1))) 2>/dev/null'` in
    2) myex 'SVR4 Bourne shell (SunOS 5 schily variant, posix-like, since 2016-05-24)'
  ;;*) myex 'SVR4 Bourne shell (SunOS 5 schily variant, since 2016-02-02, before 2016-05-24)'
  ;;esac
;;esac

type -F >/dev/null 2>&1 &&
  myex 'SVR4 Bourne shell (SunOS 5 schily variant, since 2016-08-08, in posix mode)'

# Almquist shell aka ash
(typeset -i var) 2>/dev/null || {
  case $SHELLVERS in "ash 0.2") myex 'original ash';;esac
  test "$1" = "debug" && debug=1
  n=1; case `(! :) 2>&1` in *not*) n=0;;esac
  b=1; case `echo \`:\` ` in '`:`') b=0;;esac
  g=0; { set -- -x; getopts x: var
         case $OPTIND in 2) g=1;;esac;} >/dev/null 2>&1
  p=0; (eval ': ${var#value}') 2>/dev/null && p=1
  r=0; ( (read</dev/null)) 2>/dev/null; case $? in 0|1|2)
	  var=`(read</dev/null)2>&1`; case $var in *arg*) r=1;;esac
	;;esac
  v=1; set x; case $10 in x0) v=0;;esac
  t=0; (PATH=;type :) >/dev/null 2>&1 && t=1
  test -z "$debug" || echo debug '$n$b$g$p$r$v$t: ' $n$b$g$p$r$v$t
  case $n$b$g$p$r$v$t in
     00*) myex 'early ash (4.3BSD, 386BSD 0.0-p0.2.3/NetBSD 0.8)'
  ;; 010*) myex 'early ash (ash-0.2 port, Slackware 2.1-8.0,'\
	'386BSD p0.2.4, NetBSD 0.9)'
  ;; 1110100) myex 'early ash (Minix 2.x-3.1.2)'
  ;; 1000000) myex 'early ash (4.4BSD Alpha)'
  ;; 1100000) myex 'early ash (4.4BSD)'
  ;; 11001*) myex 'early ash (4.4BSD Lite, early NetBSD 1.x, BSD/OS 2.x)'
  ;; 1101100) myex 'early ash (4.4BSD Lite2, BSD/OS 3 ff)'
  ;; 1101101) myex 'ash (FreeBSD -10.x, Cygwin pre-1.7, Minix 3.1.3 ff)'
  ;; 1111101) myex 'ash (FreeBSD 11.0 ff)'
  ;; esac
  e=0; case `(PATH=;exp 0)2>&1` in 0) e=1;;esac
  n=0; case y in [^x]) n=1;;esac
  r=1; case `(PATH=;noexist 2>/dev/null) 2>&1` in
        *not*) r=0 ;; *file*) r=2 ;;esac
  f=0; case `eval 'for i in x;{ echo $i;}' 2>/dev/null` in x) f=1;;esac
  test -z "$debug" || echo debug '$e$n$r$a$f: ' $e$n$r$a$f
  case $e$n$r$f in
     1100) myex 'ash (dash 0.3.8-30 - 0.4.6)'
  ;; 1110) myex 'ash (dash 0.4.7 - 0.4.25)'
  ;; 1010) myex 'ash (dash 0.4.26 - 0.5.2)'
  ;; 0120|1120|0100) myex 'ash (Busybox 0.x)'
  ;; 0110) myex 'ash (Busybox 1.x)'
  ;;esac
  a=0; case `eval 'x=1;(echo $((x)) )2>/dev/null'` in 1) a=1;;esac
  x=0; case `f(){ echo $?;};false;f` in 1) x=1;;esac
  c=0; case `echo -e '\x'` in *\\x) c=1;;esac
  test -z "$debug" || echo debug '$e$n$r$f$a$x$c: ' $e$n$r$f$a$x$c
  case $e$n$r$f$a$x$c in
     1001010) myex 'ash (Slackware 8.1 ff, dash 0.3.7-11 - 0.3.7-14)'
  ;; 10010??) myex 'ash (dash 0.3-1 - 0.3.7-10, NetBSD 1.2 - 3.1/4.0)'
  ;; 10011*)  myex 'ash (NetBSD 3.1/4.0 ff)'
  ;; 00101*)  myex 'ash (dash 0.5.5.1 ff)'
  ;; 00100*)  myex 'ash (dash 0.5.3-0.5.5)'
  ;;      *)  myex 'unknown ash'
  ;;esac
}

savedbg=$! # save unused $! for a later check

# Korn shell ksh93, $KSH_VERSION not implemented before 93t'
# protected: fatal substitution error in non-ksh
( eval 'test "x${.sh.version}" != x' ) 2>/dev/null &
wait $! && { eval 'PATH=;case $(XtInitialize 2>&1) in Usage*)
    DTKSH=" (dtksh/CDE variant)";;esac
    myex "ksh93 ${.sh.version}${DTKSH}"'; }

# Korn shell ksh86/88
_XPG=1;test "`typeset -Z2 x=0; echo $x`" = '00' && {
  case `print -- 2>&1` in *"bad option"*)
    myex 'ksh86 Version 06/03/86(/a)';; esac
  test "$savedbg" = '0'&& myex 'ksh88 Version (..-)11/16/88 (1st release)'
  test ${x-"{a}"b} = '{ab}' && myex 'ksh88 Version (..-)11/16/88a'
  case "`for i in . .; do echo ${i[@]} ;done 2>&1`" in
    "subscript out of range"*)
    myex 'ksh88 Version (..-)11/16/88b or c' ;; esac
  test "`whence -v true`" = 'true is an exported alias for :' &&
    myex 'ksh88 Version (..-)11/16/88d'
  test "`(cd /dev/null 2>/dev/null; echo $?)`" != '1' &&
    myex 'ksh88 Version (..-)11/16/88e'
  test "`(: $(</file/notexistent); echo x) 2>/dev/null`" = '' &&
    myex 'ksh88 Version (..-)11/16/88f'
   case `([[ "-b" > "-a" ]]) 2>&1` in *"bad number"*) \
    myex 'ksh88 Version (..-)11/16/88g';;esac # fixed in OSR5euc
  test "`cd /dev;cd -P ..;pwd 2>&1`" != '/' &&
    myex 'ksh88 Version (..-)11/16/88g' # fixed in OSR5euc
  test "`f(){ typeset REPLY;echo|read;}; echo dummy|read; f;
     echo $REPLY`" = "" && myex 'ksh88 Version (..-)11/16/88h'
  test $(( 010 )) = 8 &&
    myex 'ksh88 Version (..-)11/16/88i (posix octal base)'
  myex 'ksh88 Version (..-)11/16/88i'
}

echo 'UNKNOWN'
]

}


# FUNCTION
# check_params:		Check parametrization for validity.
#					This is done before any data is produced.
#					So we can use g.message -e/exit here to abort without
#					triggering any clean-ups!
check_params () {
	
	if [ ${GIS_OPT_SQLBUFLEN} -lt 1 ] ; then
		exit_error "SQL buffer size must be > 0 (option 'sqlbuflen=')."
	fi

}


# FUNCTION
# check_environment: Query GRASS environment for some important variables.
check_environment () {

	# Set GRASS verbosity (no --q or --v given):
	if [ -z "$GRASS_VERBOSE" ] ; then
		GRASS_VERBOSE=1
	fi

	# Determine/report shell capabilities
	interpreter=`get_interpreter`
	if [ ${GRASS_VERBOSE} -gt 2 ] ; then
		g.message -i "Running in '$interpreter'."
	fi
	is_bash=0
	is_bourne=0
	is_bash=`${ECHO} ${interpreter} |${GREP} "bash" -c`
	is_bourne=`${ECHO} ${interpreter} |${GREP} "Bourne" -c`
	if [ $is_bash -eq 0 ] ; then # We are NOT running in Bash!
		if [ $is_bourne -eq 1 ] ; then # This seems to be the original Bourne shell.
			g.message -w "Running in slow Bourne shell compatibility mode."
			g.message -w "For better performance, try running this script in Bash explicitly."
		else # This seems to be neither Bash nor Bourne.
			g.message -w "Could not assert that the current interpreter is Bash or Bourne shell."
			g.message -w "If this script throws inexplicable errors, try running it in Bash."
			g.message -w "Assuming compatibility with Bash version $BASH_VERSION_MIN."
			BASH_VERSION="$BASH_VERSION_MIN"
		fi
	else # We are running in Bash!
		if [ -z $BASH_VERSION ] ; then
			# If BASH_VERSION has not been set at this point then we just assume a version!
			g.message -w "BASH_VERSION not set. Assuming at least version $BASH_VERSION_MIN."
			BASH_VERSION="$BASH_VERSION_MIN"			
		fi
		# Get Bash major version as currently set.
		bash_version_major=`${ECHO} "$BASH_VERSION" | ${CUT} -f1 -d.`
		if [ ${GRASS_VERBOSE} -gt 2 ] ; then
			g.message -i "Detected Bash version '$bash_version_major'."
		fi
		if [ ${bash_version_major} -lt ${BASH_VERSION_MIN} ] ; then
			g.message -w "Bash version is lower than assumed minimal version (${BASH_VERSION_MIN})."
			g.message -w "Expect trouble."
		fi
	fi
	
	# Get essential GRASS environment settings
	GISDBASE=`g.gisenv get=GISDBASE`
	LOCATION_NAME=`g.gisenv get=LOCATION_NAME`
	MAPSET=`g.gisenv get=MAPSET`
	
	# Get current region settings.
	eval `g.region -p -g`	

	# Store projection (to differentiate x/y and lat/lon)
	GRASS_REG_PROJECTION="${projection}"
	if [ "${GRASS_REG_PROJECTION}" = "3" ] ; then
		g.message -w "Running in lat/lon mode. Expect reduced performance."
	fi

	# Get current GRASS database connection	
	cmd=`db.connect -pg`
	check_error "Failed to query GRASS session for current database connection ('db.connect')."
	eval_ws_safe "${cmd}" "driver"
	GRASS_DB_driver="${EVAL_RESULT}"
	eval_ws_safe "${cmd}" "database"
	GRASS_DB_database="${EVAL_RESULT}"
	
	# Ensure that we are running with a supported DBMS!
	# A supported DBMS must have sufficient SQL capabilities for this script's attribute data
	# operations.
	DBMS_SUPPORTED=0
	DBMS_NAME="unsupported"
	# SQLite: Sufficient SQL capabilities, but not thread-safe with default setup
	# (=one SQLite database per mapset).
	if [ "${GRASS_DB_driver}" = "sqlite" ] ; then
		DBMS_SUPPORTED=1
		DBMS_NAME="SQLite"		
		DBMS_INDEX_SUPPORTED=1
		DBMS_PRESERVES_ORDER=1
		DBMS_IDENT_QUOTE="'"
		# It is possible to force the SQLite backend driver to use one
		# DB per vector map instead of one DB per mapset.
		result=`"${ECHO}" "$GRASS_DB_database" | "${GREP}" '/vector/$MAP/' -c`
		if [ ${result} -gt 0 ] ; then
			DBMS_THREAD_SAFE=1
			g.message -w "SQLite backend appears to be in per-map mode. Expect errors."
		else
			if [ ${GRASS_VERBOSE} -gt 2 ] ; then
				g.message -i "SQLite backend appears to be in default mode (single database)."
			fi
		fi
		DBMS_FILE_PATH=1
	fi
	# PostgreSQL: Full SQL capabilities and thread safe
	if [ "${GRASS_DB_driver}" = "pg" ] ; then
		DBMS_SUPPORTED=1
		DBMS_NAME="PostgreSQL"
		DBMS_THREAD_SAFE=1
		DBMS_INDEX_SUPPORTED=1
		DBMS_PRESERVES_ORDER=0
		DBMS_IDENT_QUOTE='"'
	fi
	# MySQL/MariaDB: Full SQL capabilities and thread safe
	if [ "${GRASS_DB_driver}" = "mysql" ] ; then
		g.message -w "MySQL/MariaDB used: Use input data with minimal number of attribute fields to avoid storage size errors."
		DBMS_SUPPORTED=1
		DBMS_NAME="MySQL/MariaDB"		
		DBMS_THREAD_SAFE=1
		DBMS_INDEX_SUPPORTED=1
		DBMS_PRESERVES_ORDER=1
		DBMS_IDENT_QUOTE='`'
	fi
	# Embedded version of MySQL/MariaDB: Full SQL capabilities and thread safe
	if [ "${GRASS_DB_driver}" = "mesql" ] ; then
		DBMS_SUPPORTED=1
		DBMS_NAME="MySQL/MariaDB (embedded)"
		DBMS_THREAD_SAFE=1
		DBMS_INDEX_SUPPORTED=1
		DBMS_PRESERVES_ORDER=1
		DBMS_IDENT_QUOTE='`'
	fi
	if [ ${DBMS_SUPPORTED} -lt 1 ] ; then
		exit_error "Current mapset does not use a known DBMS."
	fi	
	
	# If the DBMS cannot preserve record insertion order, then we might expect some trouble.
	if [ ${DBMS_PRESERVES_ORDER} -eq 0 ] ; then
		exit_error "Current DBMS '${GRASS_DB_driver}' (${DBMS_NAME}) does not strictly preserve record insertion order."
	fi
	if [ ${GRASS_VERBOSE} -gt 2 ] ; then
		g.message -i "Running with DBMS driver '${GRASS_DB_driver}' (${DBMS_NAME})."
	fi
}


# FUNCTION
# MAIN():	This is a bogus function. It exists only so that text
#			editors will find this as a mark when parsing the source
#		   	code in SH mode, and it will be added to the document outline. 
MAIN () {
	"${ECHO}" ""
}


########
# MAIN #
########

# Keep track of starting time.
START=`"${DATE}"`

# Only print supported DBMS?
if [ ${GIS_FLAG_P} -eq 1 ] ; then
	g.message -i "$MODULE_NAME_EXEC ($MODULE_VERSION) supports these GRASS DB drivers:"
	g.message -i "${DBMS_SUPPORT_LIST}"
	exit ${EXIT_OK}
fi

# Check GRASS environment:
check_environment

# Go!
if [ ${GRASS_VERBOSE} -gt 2 ] ; then
	g.message -i "$MODULE_NAME_EXEC ($MODULE_VERSION) started."
fi

# Run all pre-flight checks:
check_setup
check_params

# GO! GO!

# Get GRASS primary key field first:
cmd=`v.info -e map="${GIS_OPT_INPUT}" layer="${GIS_OPT_LAYER}"`
check_error "Failed to query input vector map '${GIS_OPT_INPUT}' for extended metadata."
eval_ws_safe "${cmd}" "attribute_primary_key"
if [ -z "${EVAL_RESULT}" ] ; then
	exit_error "Failed to retrieve name of GRASS primary key column for input vector map '${GIS_OPT_INPUT}'."
fi

# If user does NOT provide the name of a field for sorting, then we sort on the primary key field:
if [ -z "${GIS_OPT_BY}" ] ; then
	GIS_OPT_BY="${EVAL_RESULT}"	
fi

# When sorting on primary field, a few restrictions/limitations apply:
if [ "${GIS_OPT_BY}" = "${EVAL_RESULT}" ] ; then
	if [ "${GIS_OPT_ORDER}" != "asc" ] ; then
		# Only 'asc' sorting allowed on primary field!
		exit_error "Primary field '${GIS_OPT_BY}' can only be sorted in order 'asc'."
	fi
	# Flags can be set but will have no effect.
	if [ ${GIS_FLAG_E} -eq 1 ] || [ ${GIS_FLAG_I} -eq 1 ] || [ ${GIS_FLAG_N} -eq 1 ] || [ ${GIS_FLAG_U} -eq 1 ] ; then
		g.message -w "Sorting on primary field: flags, '-e,-i,-n,-u' have no effect."
	fi
fi

# We use the 'sort' command to sort the attribute table records.
# Like many essential GNU/BSD tools, sort is extremely powerful on current Linux and rudimentary at best on macOS.
# The following are switches that even the most primitive implementations of sort should honour:
# -b (ignore leading blanks)
# -c (check for sorted input; do not sort)
# -n (numeric sorting)
# -r (reverse sorting)
# -u (check for unique values)
#
# Configure options for 'sort' command.
sort_opts=""
# Sort order descending?
if [ "${GIS_OPT_ORDER}" = "desc" ] ; then
	# Use reverse sorting.
	sort_opts="${sort_opts} -r"
fi
# Ignore leading blanks in field values?
if [ ${GIS_FLAG_I} -eq 1 ] ; then
	# Use reverse sorting.
	sort_opts="${sort_opts} -b"
fi
# Need to use numeric sorting?
if [ ${GIS_FLAG_N} -eq 1 ] || [ "${GIS_OPT_BY}" = "${EVAL_RESULT}" ] ; then
	# Numeric sorting is forced if '-n' is set OR we are sorting in primary key!
	sort_opts="${sort_opts} -n"
else
	# Check if the field to sort on is numeric, in which case we
	# automatically switch to numeric sorting.
	fld_test_result=`v.info -c --quiet map="${GIS_OPT_INPUT}" layer="${GIS_OPT_LAYER}" | "${GREP}" "INTEGER|${GIS_OPT_BY}" -w -c`
	if [ ${fld_test_result} -eq 1 ] ; then
		sort_opts="${sort_opts} -n"
	else
		fld_test_result=`v.info -c --quiet map="${GIS_OPT_INPUT}" layer="${GIS_OPT_LAYER}" | "${GREP}" "DOUBLE PRECISION|${GIS_OPT_BY}" -w -c`
		if [ ${fld_test_result} -eq 1 ] ; then
			sort_opts="${sort_opts} -n"
		fi
	fi
fi

# Get the sorted list of "value|primary key" pairs first:
vals=`v.db.select map="${GIS_OPT_INPUT}" layer="${GIS_OPT_LAYER}" col="${GIS_OPT_BY},${EVAL_RESULT}" -c separator="${GIS_OPT_DELIMITER}"`
check_error "Failed to retrieve list of sorted key-value pairs for input vector map '${GIS_OPT_INPUT}'."
sorted_pairs=`"${ECHO}" "${vals}" | "${SORT}" ${sort_opts} 2>/dev/null`
check_error "Failed to retrieve list of value|primary keys for input vector map '${GIS_OPT_INPUT}'."
# Now get only the list of sort field values:
sorted_vals=`"${ECHO}" "${sorted_pairs}" | "${CUT}" -d "${GIS_OPT_DELIMITER}" -f 1`
check_error "Failed to retrieve list of sorted field values for input vector map '${GIS_OPT_INPUT}'."
# Now get only the list of associated primary keys in the same order.
sorted_keys=`"${ECHO}" "${sorted_pairs}" | "${CUT}" -d "${GIS_OPT_DELIMITER}" -f 2`
check_error "Failed to retrieve list of sorted primary key values for input vector map '${GIS_OPT_INPUT}'."
# Now check if there is a field #3 when using the current separator character. If so, then
# we have a problem!
check_sep=`"${ECHO}" "${sorted_pairs}" | "${CUT}" -d "${GIS_OPT_DELIMITER}" -f 3`
num_words_check=`"${ECHO}" "${check_sep}" | "${WC}" -w`
if [ ${num_words_check} -gt 0 ] ; then
	exit_error "Use option 'delimiter=' to set a field separator that does not occur as part of the data in column '${GIS_OPT_BY}'!"
fi


# Check for empty field values, unless "-e" given!
# At least one empty field value is assumed to exist, if the
# list of values returned by "sort" is longer than the number
# of variables in ${sorted_vals} which the DO loop iterates over.
if [ ${GIS_FLAG_E} -eq 0 ] ; then	
	num_lines_sort=`"${ECHO}" "${sorted_vals}" | "${WC}" -l`
	check_error "Failed to determine number of lines in output of 'sort' command."
	OLD_IFS="$IFS"
	IFS="${IFS_NEWLINE}"
	num_vals=0
	for val in ${sorted_vals} ; do
		if [ -n $BASH_VERSION ] ; then
			let num_vals=${num_vals}+1
		else
			num_vals=`"${EXPR}" ${num_vals} + 1`
		fi
	done
	if [ ${num_lines_sort} -ne ${num_vals} ] ; then
		exit_error "Empty value(s) detected in sorting field '${GIS_OPT_BY}'."
	fi	
	IFS="$OLD_IFS"
else
	if [ ${GIS_FLAG_U} -eq 1 ] ; then
		if [ "${GIS_OPT_BY}" != "${EVAL_RESULT}" ] ; then
			# Non-empty and unique field value options contradict each other!
			exit_error "Flags -e(mpty allowed) and -u(nique) must not both be set."
		fi
	fi
fi

# Unique values required? Then we check for duplicates in the sorted list of values now!
if [ ${GIS_FLAG_U} -eq 1 ] ; then
	i=1
	OLD_IFS="$IFS"
	IFS="${IFS_NEWLINE}"
	for val in ${sorted_vals} ; do
		if [ $i -gt 1 ] ; then
			if [ "${val}" = "${previous}" ] ; then
				exit_error "Duplicate field values detected in sorting field '${GIS_OPT_BY}'."
			fi
		fi
		if [ -n $BASH_VERSION ] ; then
			let i=${i}+1
		else
			i=`${EXPR} $i + 1`
		fi
		previous="${val}"
	done
	IFS="$OLD_IFS"
fi

#
# Now create sorted map by extracting first node and then patching the remaining ones to it.
# Note that v.patch will create a "cat" sequences with gaps if the attribute
# records are also patched. In addition, "v.extract" will preserve the "cat" value of
# the extracted node. In combination, both behaviours will likely lead to a "cat" sequence
# that does NOT start at "1" and has gaps. This violates our assumption about unbroken
# primary key values starting at "1". Therefore, we will extract and patch only the geometries
# at this point, discarding all attribute data. A properly sorted attribute table will be
# re-attached in the next step.
#
eval `v.info -t map="${GIS_OPT_INPUT}" layer="${GIS_OPT_LAYER}"`
check_error "Failed to get topology info for input vector map."
i=1
num_features=`"${ECHO}" "${sorted_keys}" | "${WC}" -l`
if [ ${GRASS_VERBOSE} -gt 0 ] ; then
	g.message -i "Extracting ordered features to new output map:"
fi
for cur_key in ${sorted_keys} ; do
	if [ $i -eq 1 ] ; then
		# First node: Extract into new map!
		v.extract -t input="${GIS_OPT_INPUT}" layer="${GIS_OPT_LAYER}" where="${EVAL_RESULT}=${cur_key}" output="${GIS_OPT_OUTPUT}" new="$i" --overwrite --quiet 2>/dev/null
		check_error "Failed to extract point with primary key value '${cur_key}' from input vector map."
	else
		# Every following node: Extract and patch into existing map!
		v.extract -t input="${GIS_OPT_INPUT}" layer="${GIS_OPT_LAYER}" where="${EVAL_RESULT}=${cur_key}" output="${TMP_VECT_EXTRACT}" new="$i" --overwrite --quiet 2>/dev/null
		check_error "Failed to extract point with primary key value '${cur_key}' from input vector map."
		v.patch -a input="${TMP_VECT_EXTRACT}" output="${GIS_OPT_OUTPUT}" --o --quiet
		check_error "Failed to add input node #${cur_key} to sorted map of input nodes."
	fi
	if [ ${GRASS_VERBOSE} -gt 0 ] ; then
		g.message -p "${i} ${num_features} 1"
	fi
	if [ -n $BASH_VERSION ] ; then
		let i=${i}+1
	else
		i=`${EXPR} $i + 1`
	fi
done

# We now have the geometries, in correct order and with a brand new primary
# key ("cat") sequence [1..n], but without an attribute table for the output map.
# So let's take care of that next.
#
# Get name of primary key field in input map
cmd=`v.info -e map="${GIS_OPT_INPUT}" layer="${GIS_OPT_LAYER}"`
check_error "Failed to query input vector map for extended metadata (primary key name)."
eval_ws_safe "${cmd}" "attribute_primary_key"
if [ -z "${EVAL_RESULT}" ] ; then
	exit_error "Failed to retrieve name of GRASS primary key column from input map."
fi
input_map_pkey="${EVAL_RESULT}"
# Create empty table with with primary key of same name for output map:
${V_DB_ADDTABLE} map="${GIS_OPT_OUTPUT}" layer="1" key="${input_map_pkey}" --quiet 2>/dev/null

# Copy the attribute table schema of the input map to that of the output map:
FIELDS=`v.info -c map="${GIS_OPT_INPUT}" layer="${GIS_OPT_LAYER}" --quiet`
num_fields=`v.info -c map="${GIS_OPT_INPUT}" layer="${GIS_OPT_LAYER}" --quiet | "${WC}" -l`
OLD_IFS="$IFS"
IFS="${IFS_NEWLINE}"
if [ ${GRASS_VERBOSE} -gt 0 ] ; then
	g.message -i "Adding ${num_fields} fields to output map's attribute table:"
fi
i=1
for field in ${FIELDS} ; do
	type=`"${ECHO}" "${field}" | "${CUT}" -d "|" -f 1`	
	name=`"${ECHO}" "${field}" | "${CUT}" -d "|" -f 2`
	# DEBUG
	#echo "$type|$name"
	# If there is a third field, then the field name contains "|" in which case we can
	# only bail out!
	check=`"${ECHO}" "${field}" | "${CUT}" -d "|" -f 3`
	num_words_check=`"${ECHO}" "${check}" | "${WC}" -w`
	if [ ${num_words_check} -gt 0 ] ; then
	exit_error "Field '${name}|${check}' contains '|' as part of its name. Please rename field."
fi
	if [ "${name}" != "${input_map_pkey}" ] ; then
		#DEBUG
		#echo "type='$type'; name='$name'"
		${V_DB_ADDCOLUMN} map="${GIS_OPT_OUTPUT}" layer="1" columns="${name} ${type}" --quiet 
	fi
	if [ ${GRASS_VERBOSE} -gt 0 ] ; then
		g.message -p "${i} ${num_fields} 1"
	fi
	if [ -n $BASH_VERSION ] ; then
		let i=${i}+1
	else
		i=`${EXPR} $i + 1`
	fi
done
IFS="$OLD_IFS"

# Get information on attribute table attached to the chosen layer of input map:
get_tbl_info "${GIS_OPT_INPUT}" ${GIS_OPT_LAYER}
in_driver="${attribute_database_driver}"
in_database="${attribute_database}"
in_table="${attribute_table}"

# Get info on attribute table attached to layer 1 of output map:
get_tbl_info "${GIS_OPT_OUTPUT}"
out_driver="${attribute_database_driver}"
out_database="${attribute_database}"
out_table="${attribute_table}"

# Currently, we only support tables stored in the same DB and managed by the same driver!
if [ "$in_driver" != "$out_driver" ] || [ "$in_database" != "$out_database" ] ; then
	exit_error "This version of $MODULE_NAME_EXEC requires input and output maps to use the same attribute table database."
fi

# Copy all field values from the input to the output attribute table, and sort them at the same time:
num_records=`v.db.select -c map="${GIS_OPT_OUTPUT}" layer="1" | "${WC}" -l`

check_error "Failed to determine number of records in output map."

# Initialize chunk-based SQL statement collation
if [ ${GIS_OPT_SQLBUFLEN} -gt ${num_records} ] ; then
	g.message -w "Adjusted SQL buffer size to number of input records."
	chunk_size=${num_records}
else
	chunk_size=${GIS_OPT_SQLBUFLEN} # Number of SQL statements to collate before executing them (initialize to default)
fi
chunk_left=${chunk_size} # Number SQL statements left to collate in current chunk
# Set Threshold variable for determining when to execute leftover statements in single mode:
chunk_remainder=`"${EXPR}" ${num_records} % ${chunk_size}`
# Initialize contents of first SQL_CHUNK to 'empty':
SQL_CHUNK="${DBMS_BEGIN}"
if [ ${GRASS_VERBOSE} -gt 0 ] ; then
	g.message -i "Sorting and updating ${num_records} records:"
fi

# Set newline separator for the main processing loop:
OLD_IFS="$IFS"
IFS="${IFS_NEWLINE}"

# Main processing loop starts here:
i=1
while [ ${i} -le ${num_records} ] ; do
	# Check if chunk size needs to be set to "1" (=single SQL transactions for remainder dataset)
	if [ -n $BASH_VERSION ] ; then
		let records_left=${num_records}-${i}
	else
		records_left=`${EXPR} ${num_records} - ${i}`
	fi
	if [ ${records_left} -lt ${chunk_remainder} ] ; then
		chunk_size=1
	fi
	#
	j=1
	for cur_key in $sorted_keys ; do
		if [ $j -eq $i ] ; then
			pkey="${cur_key}"
			break;
		fi
		if [ -n $BASH_VERSION ] ; then
			let j=${j}+1
		else
			j=`${EXPR} $j + 1`
		fi
	done;
	# Step through all fields of input map, copy all values to corresponding fields of output map:
	# Create SQL statement for attribute record update
	SQL=""
	for field in ${FIELDS} ; do
		# Get value from field in input map
		name=`"${ECHO}" "${field}" | "${CUT}" -d "|" -f 2`
		if [ "${name}" != "${input_map_pkey}" ] ; then # We copy anything, except the GRASS primary key!				
			SQL="${SQL}
UPDATE ${out_table} SET ${name} = (SELECT ${name} FROM ${in_table} where ${input_map_pkey}=${pkey}) WHERE ${input_map_pkey}=${i};"
		fi
	done
	#
	if [ ${chunk_size} -gt 1 ] && [ ${chunk_left} -gt 1 ] ; then
		# Keep collecting statements for current chunk.
		SQL_CHUNK="${SQL_CHUNK}
${SQL}"	
		if [ -n $BASH_VERSION ] ; then
			let chunk_left=${chunk_left}-1
		else
			chunk_left=`${EXPR} ${chunk_left}-1`
		fi
	else
		if [ ${chunk_size} -eq 1 ] ; then
			SQL_CHUNK="$SQL" # Chunk contains only one piece.
		else
			# Add final chunk piece:
			SQL_CHUNK="${SQL_CHUNK}
${SQL}
${DBMS_COMMIT}"
		fi
		#
		# Update all attribute fields of all records in current chunk at once:
		"${ECHO}" "${SQL_CHUNK}" | db.execute database="${out_database}" driver="${out_driver}" input="-"
		check_error "Failed to update SQL chunk of size ${chunk_size}."
		# Empty chunk contents:
		SQL_CHUNK="${DBMS_BEGIN}"
		chunk_left=${chunk_size}
	fi
	#	
	if [ ${GRASS_VERBOSE} -gt 0 ] ; then
		g.message -p "${i} ${num_records} 1"
	fi
	if [ -n $BASH_VERSION ] ; then
		let i=${i}+1
	else
		i=`${EXPR} $i + 1`
	fi
done

# Reset newline separator to default:
IFS="$OLD_IFS"

# DONE!

# Remove temp. maps, restore region, etc.
clean_up

# Show processing time.
if [ ${GRASS_VERBOSE} -gt 2 ] ; then
	g.message -i "Success."
	g.message -i "Started: ${START}"
	END=`"${DATE}"`
	g.message -i "Completed: ${END}"
fi

# Exit with status "OK"
exit ${EXIT_OK}
