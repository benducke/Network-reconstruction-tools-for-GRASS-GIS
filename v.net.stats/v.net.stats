#!/usr/bin/env bash
############################################################################
#
# MODULE:     	v.net.stats
# AUTHOR(S): 	Benjamin Ducke <benducke AT fastmail.fm>
# PURPOSE:		Produces statistics for output maps generated by v.net.models.
#				This script accepts only vector maps as input that were
#				generated by the 'links=' option of v.net.models.
#				It queries the attribute table of such a map and computes
#				some descriptive statistics based on the values of various
#				attribute fields (columns). The statistics are then printed
#				to stdout.
#
# COMPATIBILITY:
#				This script has been written to run under GRASS 8 (and possibly
#				any later version that retains the GRASS 8 syntax for the GRASS
#				commands called by this script).
#
# COPYRIGHT:    (C) 2024 by Benjamin Ducke
#
#               This program is free software under the GNU General Public
#               License (>=v2). Read the file COPYING that comes with GRASS
#               for details.
#
#############################################################################


# CAVEATS/TODO/LIMITATIONS
# * This script makes heavy use of direct SQL execution. It will only run if the current GRASS session is
#   using one of the supported DBMS backends.

#
# REQUIRED EXTERNAL PROGRAMS:
# - awk
# - cut
# - date
# - echo (on Windows)
# - expr
# - grep
# - sort
# - wc
#


# %Module
# % description: Produces statistics for output maps generated by v.net.models.
# % keywords: vector, networks, v.net.models, statistics
# %End

# %Flag
# %  key: a
# %  description: Append statistical report to existing text file
# %End

# %Flag
# %  key: f
# %  description: Force overwrite of input maps' existing field values
# %End

# %Flag
# %  key: g
# %  description: Print statistics in shell script style
# %End

# %Flag
# %  key: s
# %  description: Skip input data consistency checks
# %End


# %Option
# % key: links
# % type: string
# % required: yes
# % multiple: no
# % key_desc: name
# % description: Input vector map with network links (lines)
# % gisprompt: old,vector,vector
# %End


# %Option
# % key: nodes
# % type: string
# % required: yes
# % multiple: no
# % key_desc: name
# % description: Input vector map with network nodes (points)
# % gisprompt: old,vector,vector
# %End

# %Option G_OPT_DB_COLUMN
# % key: key
# % required: yes
# % description: Name of INTEGER key field in input nodes' attribute table
# % gisprompt: old,dbcolumn,dbcolumn
# %End

# %Option
# % key: nstats
# % type: string
# % required: no
# % multiple: no
# % key_desc: name
# % description: Output nodes (points) with added statistical attributes
# % gisprompt: new,vector,vector
# %End

# %Option G_OPT_F_OUTPUT
# % key: report
# % required: no
# % description: Output text file for statistical report
# % gisprompt: new,file,file
# %End

# %option
# % key: title
# % type: string
# % required: no
# % description: Title string for statistical report
# %end

# Basic module setup.
MODULE_NAME="v_net_stats" # for prefixing temporary object names
MODULE_NAME_EXEC="v.net.stats" # name as run on the command line
MODULE_VERSION="1.1.0"

# System setup: Modify if needed.
if [ -n "${MSYSPATH}" ] ; then
	# "MSYSPATH" was set by the Windows ".bat" script that called
	# this script. It contains the path to the "bin" folder of
	# the local MSYS(2) installation, using Linux style "/" separators
	# but NOT INCLUDING the final path separator, like so:
	# "/c/msys64/usr/bin"
	# That means we are running under MS Windows,
	# and we must make some adjustments to external program calls!
	AWK="${MSYSPATH}/awk.exe"
	CUT="${MSYSPATH}/cut.exe"
	DATE="${MSYSPATH}/date.exe"
	ECHO="${MSYSPATH}/echo.exe"	
	EXPR="${MSYSPATH}/expr.exe"	
	GREP="${MSYSPATH}/grep.exe"
	SORT="${MSYSPATH}/sort.exe"
	WC="${MSYSPATH}/wc.exe"
	# Scripted GRASS commands require ".bat" extensions for Windows, or else "sh.exe" won't find them!
	V_DB_ADDCOLUMN="v.db.addcolumn.bat"
	V_DB_ADDTABLE="v.db.addtable.bat"
	# Set filter for line endings for this system:
	IFS_NEWLINE=$'\r\n\b'
else
	AWK="awk"
	CUT="cut"
	DATE="date"
	ECHO="echo"
	EXPR="expr"
	GREP="grep"	
	SORT="sort"
	PKILL="pkill"
	WC="wc"
	# These are the GRASS commands that are actually Shell/Python scripts.
	# On Linux/macOS they are executed through the shell, just like binaries.
	V_DB_ADDCOLUMN="v.db.addcolumn"
	V_DB_ADDTABLE="v.db.addtable"
	# Set filter for line endings for this system:
	IFS_NEWLINE=$'\n\b'
fi

# Minimal Bash version for expected to run this script without errors.
BASH_VERSION_MIN="3" # Version 3 is the latest one shipped on macOS!

# Keep a copy of IFS, as it was set before running this script!
IFS_ORIGINAL="$IFS"

# Exit status variables.
EXIT_OK=0
EXIT_CTRL_C=1
EXIT_TERMINATED=2
EXIT_ERROR=3

# Processing states.
RUNMODE_COST="FALSE" # Cost-based processing mode

# DBMS backend idiosyncracies
DBMS_LOCKS_REQUIRED=0   # DBMS locking off (will be set later, as required)
DBMS_THREAD_SAFE=0		# Indicates whether the DBMS is thread safe (in the context of this script)
DBMS_INDEX_SUPPORTED=0  # Indicates whether the DBMS supports building an index.
DBMS_PRESERVES_ORDER=0  # Indicates whether the DBMS preserves order of record insertion reliably.
DBMS_FILE_PATH=0		# Indicates whether the DBMS driver uses a file path to specify the location of a database.
DBMS_IDENT_QUOTE='"'	# Quoting character for field/table names that (might) contain spaces
DBMS_BEGIN="BEGIN;"		# Opening statement for an SQL transction; most DBMS should understand "BEGIN;"
DBMS_COMMIT="COMMIT;";	# Closing statement for an SQL transction; most DBMS should understand "COMMIT;"

# Reserved names of attribute table fields in LINKS input map
LINKS_FLD_FROM_ID="from_id"		# ID of start node
LINKS_FLD_TO_ID="to_id"			# ID of end node
LINKS_FLD_FROM_LBL="from_lbl"	# Label (name) of start node
LINKS_FLD_TO_LBL="to_lbl"		# Label (name) of end node
LINKS_FLD_FROM_X="from_x"		# X coordinates of start node.
LINKS_FLD_FROM_Y="from_y"		# Y coordinates of start node.
LINKS_FLD_TO_X="to_x"			# X coordinates of end node.
LINKS_FLD_TO_Y="to_y"			# Y coordinates of end node.
LINKS_FLD_LEN_M="length_m"		# Total length of link in meters
LINKS_FLD_LEN_KM="length_km" 	# Total length of link in kilometers
LINKS_FLD_COST="cost"			# Total cost of link in unspecified units (will only exist if 'costmap=" provided)

# Reserved names of attribute table fields in NODES input map
NODES_FLD_LINKS="links_num" 	# Number of links connected to node
NODES_FLD_LEN_SUM="len_sum" 	# Sum of lengths of links connected to node
NODES_FLD_LEN_AVG="len_mean" 	# Mean length of links connected to node
NODES_FLD_COST_SUM="cost_sum" 	# Sum of costs of links connected to node
NODES_FLD_COST_AVG="cost_mean" 	# Mean cost of links connected to node

# Basic sanity checks.
if [ -z "$GISBASE" ] ; then
    "${ECHO}" "ERROR: You must be in GRASS GIS to run this program." 1>&2
    exit ${EXIT_ERROR}
fi

if [ "$1" != "@ARGS_PARSED@" ] ; then
    exec g.parser "$0" "$@"
fi

# Check if we are running under old GRASS 6
GRASS_V6=`g.version -e | "${GREP}" "GRASS 6"`

# Check if we are running under old GRASS 7
GRASS_V7=`g.version -e | "${GREP}" "GRASS 7"`

# Check if we are running under old GRASS 8
GRASS_V8=`g.version -e | "${GREP}" "GRASS 8"`

if [ -n "$GRASS_V6" ] ; then
	g.message -e "This script requires GRASS GIS version 7 or higher."
	exit ${EXIT_ERROR}
fi

# Create prefix for all temporary maps
TMP_PREFIX="tmp_${MODULE_NAME}_`"${ECHO}" $$`_d"

# Names of temporary maps (VECTOR)
TMP_VECT_EXTRACT="${TMP_PREFIX}_v_extract" 				# Feature(s) extracted from input vector map


# FUNCTION
# list_len:		Computes the length of a list of values (array).
#				This function takes only one argument:
#				
#				$1 -- a list/array
#
#				REMEMBER to put "$1" in quotes of the list values are separated by whitespace!
#
#				The result will be returned as an integer in the variable LIST_LEN.
#
list_len () {
	
	# IMPORTANT! We change IFS, but save the current value to a local(ly named)
	# variable, so that this will work without clashes from within a caller
	# caller loop that also fiddles around with IFS (not uncommon)!
	OLD_IFS_LIST_LEN="$IFS"
	IFS="$IFS_NEWLINE"
	
	LIST_LEN=0
	for item in $1 ; do
		if [ -n $BASH_VERSION ] ; then
			let LIST_LEN=${LIST_LEN}+1
		else
			LIST_LEN=`"${EXPR}" ${LIST_LEN} + 1`
		fi
	done
	
	# IMPORTANT: Reset IFS!
	IFS="$OLD_IFS_LIST_LEN"
}


# FUNCTION
# list_get:		Retrieves an item from a list of values (array).
# 				This function takes two arguments:
#				
#				$1 -- a list/array
#				$2 -- an integer that is the number of the item to get (0 or larger)
#				$3 -- (optional): an integer that represents the list length (for upper boundary checks)
#
#				REMEMBER to put "$1" in quotes if the list values are separated by whitespace!
#
#				The requested value will be returned in variable LIST_ITEM.
#				LIST_ITEM can be empty if the list is empty.
#				An error will be thrown if $2 contains an invalid index value.
#
list_get () {
	
	# IMPORTANT! We change IFS, but save the current value to a local(ly named)
	# variable, so that this will work without clashes from within a caller
	# caller loop that also fiddles around with IFS (not uncommon)!
	OLD_IFS_LIST_GET="$IFS"
	IFS="$IFS_NEWLINE"
	
	LIST_ITEM=
	if [ $2 -lt 0 ] ; then
		exit_error "list_get(): Attempted to read list/array using negative index value."
	fi

	# Getting the list length every time before retreiving an element, just for
	# boundary checking, incurs a huge performance penalty. So uppper boundary checking
	# is optional (by passing the known list length as $3 in addition):
	if [ -n "$3" ] ; then
		if [ $2 -gt $3 ] ; then
			exit_error "list_get(): Attempted to read list/array using out-of-bounds index value."
		fi
	fi

	cur_list_item=0
	for item in $1 ; do
		LIST_ITEM="${item}"
		if [ ${cur_list_item} -eq $2 ] ; then
			# Got item: Return.
			break
		else
			# Get next item.
			if [ -n $BASH_VERSION ] ; then
				let cur_list_item=${cur_list_item}+1
			else
				cur_list_item=`"${EXPR}" ${cur_list_item} + 1`
			fi
		fi
	done
	
	# IMPORTANT: Rest IFS!
	IFS="$OLD_IFS_LIST_GET"	
}


# FUNCTION
# clean_up: Remove temporary maps, reset region to what it was, etc.
clean_up () {
	
	g.message -i "Cleaning up..."
	
	# Feature(s) extracted from input vector map.
	type="vector"
	elem="${TMP_VECT_EXTRACT}"
	found=`g.list type="${type}" | "${GREP}" -c "${elem}"`
	if [ $found -gt 0 ] ; then
		g.remove type="${type}" name="${elem}" -f --q 2>/dev/null
	fi
}
	

# Make sure we get to clean up!
trap "g.message -i 'Terminated by user (CTRL+C).' ; clean_up ; exit ${EXIT_CTRL_C}" 2 # user interrupt (CTRL+C)
#trap "'Unexpected termination.' ; clean_up ; exit ${EXIT_TERMINATED}" 1 # external interrupt


# FUNCTION
# awk_calc:		Uses AWK to calculate an expression and returns the result
#				in 'AWK_VALUE', e.g.:
#				awk_calc "((1+(2^3.4))/9)-2"
#
#				Result will be returned in variable 'AWK_VALUE'
awk_calc () {
	AWK_VALUE=`"${AWK}" "BEGIN{ print $* }"`
}


# FUNCTION
# awk_equal:	Uses AWK to test whether two numbers are equal.
#				The two numbers must be passed as $1 as $2.
#				Result will be returned in variable 'AWK_VALUE':
#					1 = equal
#					0 = not equal
awk_equal () {
	AWK_VALUE=`"${AWK}" "BEGIN{ print $1==$2 }"`
}


# FUNCTION
# awk_smaller:	Uses AWK to test whether $1 is smaller than $2
#				Result will be returned in variable 'AWK_VALUE':
#					1 = $1 < $2
#					0 = $1 >= $2
awk_smaller () {
	AWK_VALUE=`"${AWK}" "BEGIN{ print $1<$2 }"`
}


# FUNCTION
# awk_smaller_eq:	Uses AWK to test whether $1 is smaller or equal $2
#					Result will be returned in variable 'AWK_VALUE':
#					1 = $1 <= $2
#					0 = $1 > $2
awk_smaller_eq () {
	AWK_VALUE=`"${AWK}" "BEGIN{ print $1<=$2 }"`
}


# FUNCTION
# awk_larger:	Uses AWK to test whether $1 is larger than $2
#				Result will be returned in variable 'AWK_VALUE':
#					1 = $1 > $2
#					0 = $1 <= $2
awk_larger () {
	AWK_VALUE=`"${AWK}" "BEGIN{ print $1>$2 }"`
}


# FUNCTION
# awk_larger_eq:	Uses AWK to test whether $1 is larger or equal $2
#					Result will be returned in variable 'AWK_VALUE':
#					1 = $1 >= $2
#					0 = $1 < $2
awk_larger_eq () {
	AWK_VALUE=`"${AWK}" "BEGIN{ print $1>=$2 }"`
}


# FUNCTION
# awk_abs:		Uses AWK to calculate the absolute difference between two numbers.
#				The two numbers must be passed as $1 as $2.
#				Result will be returned in variable 'AWK_VALUE'
awk_abs () {
	AWK_VALUE=`"${AWK}" 'BEGIN{x = $1-$2; print x < 0 ? -x : x}'`
}


# FUNCTION
# awk_min:		Uses AWK to compare two numbers passed in $1 and $1 using "<".
#				'AWK_VALUE' will be set to the smaller of the two.
#				If the first number is passed as empty string, then 'AWK_VALUE'
#				will be the second number.
#				
#				Note: The "0+" in the awk program forces type conversion to
#				numeric (otherwise, awk will compare by character position).
awk_min () {
	if [ -z "$1" ] ; then
		AWK_VALUE="$2"
	else
		AWK_VALUE="$1"
		min=`"${ECHO}" "$1 $2" | "${AWK}" "BEGIN{}{if (0+$2<0+$1) min=$2} END{print min}"`
		if [ -n "${min}" ] ; then
			AWK_VALUE="$min"
		fi
	fi
}


# FUNCTION
# awk_max:		Uses AWK to compare two numbers passed in $1 and $1 using ">".
#				'AWK_VALUE' will be set to the larger of the two.
#				If the first number is passed as empty string, then 'AWK_VALUE'
#				will be the second number.
#				
#				Note: The "0+" in the awk program forces type conversion to
#				numeric (otherwise, awk will compare by character position).
awk_max () {
	if [ -z "$1" ] ; then
		AWK_VALUE="$2"
	else
		AWK_VALUE="$1"
		max=`"${ECHO}" "$1 $2" | "${AWK}" "BEGIN{}{if (0+$2>0+$1) max=$2} END{print max}"`
		if [ -n "${max}" ] ; then
			AWK_VALUE="$max"
		fi
	fi
}


# FUNCTION awk_median:	Compute median for a list of values.
#						Reads just one argument:
#						
#						$1 -- list of values (separated by line breaks!)
#
#						Result is returned in variable 'AWK_VALUE'.
#						An empty value will be returned if there are no values
#						found in $1.
awk_median () {
	
	# NOTE Below (commented out) is the command for sorting with AWK. However, only GNU AWK provides 'asorti(a,b)', 
	# so this would not work on macOS (would need to install 'gawk' through e.b. MacPorts).
	# med_list=`"${ECHO}" "$1" | "${AWK}" '{a[$0]}END{asorti(a,b,"@ind_num_asc");for(i=1;i<=NR;i++)print b[i]}'`
	#
	# Sort list of input values in $1, numerically, ascending:
	med_list=`"${ECHO}" "$1" | "${SORT}" -n`
	# Get number of items on list:
	list_len "${med_list}"
	if [ -z "${med_list}" ] || [ ${LIST_LEN} -eq 0 ] ; then
		AWK_VALUE=""
	else
		if [ ${LIST_LEN} -eq 1 ] ; then
			# special case: just one item on list
			list_get "${med_list}" 0
			awk_median_val="${med_list}"
		fi
		if [ ${LIST_LEN} -eq 2 ] ; then
			# special case: just two items on list
			list_get "${med_list}" 0
			a="${LIST_ITEM}"
			list_get "${med_list}" 1
			b="${LIST_ITEM}"
			awk_calc "(${a}+${b})/2"
			awk_median_val="${AWK_VALUE}"
		fi
		# This is the non-special case:
		if [ ${LIST_LEN} -gt 2 ] ; then
			if [[ $((${LIST_LEN} % 2)) -eq 0 ]] ; then
				# Even list length: median is the mean of the two values at the
				# list's center.
				posa=`"${EXPR}" ${LIST_LEN} / 2`
				posb=`"${EXPR}" ${posa} - 1`
				list_get "${med_list}" "${posa}"
				a="${LIST_ITEM}"
				list_get "${med_list}" "${posb}"
				b="${LIST_ITEM}"
				awk_calc "(${a}+${b})/2"
				awk_median_val="${AWK_VALUE}"		
			else
				# Odd index: median is the value at the list's center.
				posa=`"${EXPR}" ${LIST_LEN} / 2`
				list_get "${med_list}" "${posa}"
				awk_median_val="${LIST_ITEM}"
			fi
		fi
		# Result
		AWK_VALUE="$awk_median_val"
	fi
	
}


# FUNCTION
# check_field: Checks attribute field validity.
#
# Number of tests depends on number of arguments provided.
# Arguments are positional:
# 	$1 - Name of map for which to test attribute field
#	$2 - Name of attribute field to test (case sensitive)
#   $3 - Field type to test for. Can be one of (case matters!):
#       "INTEGER"
#       "DOUBLE PRECISION"
#       "NUMERIC"
#       "TEXT"
#		"ANY"
#		(The first four match the GRASS GIS field data types!)
#   $4 - All field contents must be non-empty? Can be one of (case matters!):
#		"TRUE"
#		"FALSE"
#   $5 - Field contents must be unique? Can be one of (case matters!):
#		"TRUE"
#		"FALSE"
#
# It is always assumed that the name of the attribute table is identical
# with the name of the map in $1, and that the table is connected as layer 1.
#
# This function will quit the entire program, if an error occurs
# while querying the field or its contents!
#
# Return value is stored in RET_FLD_TEST as a string:
#   == field name ($2): ok (all tests passed)
#   != field name ($2): not all tests passed (return string contains descr of first failed test) 
#   empty = unknown error
#
check_field () {
	
	FLD_TEST_KEY_TYPE="${3}"
	
	# Initialize return value:	
	RET_FLD_TEST=""
	
	# 1. Check if field exists (always run)
	fld_test_result=`v.info -c --quiet map="${1}" layer="1" | ${CUT} -f 2 -d "|" | "${GREP}" "${2}" -w`
	if [ "${fld_test_result}" != "${2}" ] ; then
		RET_FLD_TEST="Field '$2' does not exist in attribute table of map '$1'."
		return
	fi
	
	# 2. Check for given field type (run if at least three arguments given)
	if [ $# -gt 2 ] ; then
		fld_test_key_type="UNKNOWN"
		fld_test_result=`v.info -c --quiet map="${1}" layer="1" | "${GREP}" "INTEGER|${2}" -w -c`
		if [ ${fld_test_result} -eq 1 ] ; then
			fld_test_key_type="INTEGER"
			if [ "$FLD_TEST_KEY_TYPE" != "INTEGER" ] && [ "$FLD_TEST_KEY_TYPE" != "NUMERIC" ] && [ "$FLD_TEST_KEY_TYPE" != "ANY" ] ; then
				RET_FLD_TEST="Field '$2' in attribute table of map '$1' is not of type '$FLD_TEST_KEY_TYPE'."
				return
			fi
		fi
		fld_test_result=`v.info -c --quiet map="${1}" layer="1" | "${GREP}" "DOUBLE PRECISION|${2}" -w -c`
		if [ ${fld_test_result} -eq 1 ] ; then
			fld_test_key_type="DOUBLE PRECISION"
			if [ "$FLD_TEST_KEY_TYPE" != "DOUBLE PRECISION" ] && [ "$FLD_TEST_KEY_TYPE" != "NUMERIC" ] && [ "$FLD_TEST_KEY_TYPE" != "ANY" ] ; then
				RET_FLD_TEST="Field '$2' in attribute table of map '$1' is not of type '$FLD_TEST_KEY_TYPE'."
				return
			fi
		fi
		fld_test_result=`v.info -c --quiet map="${1}" layer="1" | "${GREP}" "CHARACTER|${2}" -w -c`
		if [ ${fld_test_result} -eq 1 ] ; then
			fld_test_key_type="CHARACTER"
			if [ "$FLD_TEST_KEY_TYPE" != "TEXT" ] && [ "$FLD_TEST_KEY_TYPE" != "ANY" ] ; then
				RET_FLD_TEST="Field '$2' in attribute table of map '$1' is not of type '$FLD_TEST_KEY_TYPE'."
				return
			fi
		fi
		fld_test_result=`v.info -c --quiet map="${1}" layer="1" | "${GREP}" "TEXT|${2}" -w -c`
		if [ ${fld_test_result} -eq 1 ] ; then
			fld_test_key_type="TEXT"
			if [ "$FLD_TEST_KEY_TYPE" != "TEXT" ] && [ "$FLD_TEST_KEY_TYPE" != "ANY" ] ; then
				RET_FLD_TEST="Field '$2' in attribute table of map '$1' is not of type '$FLD_TEST_KEY_TYPE'."
				return
			fi
		fi
		# ANY != UNKNOWN
		if [ "${fld_test_key_type}" = "UNKNOWN" ] ; then
			RET_FLD_TEST="Field '$2' in attribute table of map '$1' has unknown type."
			return
		fi
	fi
	
	# 3. Check for non-empty contents (run if at least 4 arguments given) 
	if [ $# -gt 3 ] ; then
		if [ "$4" == "TRUE" ] ; then
			# Get number of features in map:
			# We compare the number of (typical) geometries that can have
			# attributes attached with the total number of attributes
			# returned by a v.db.select query.
			# The below are all sensitive vars that might already be set!
			fld_test_points_old="${points}"
			fld_test_lines_old="${lines}"
			fld_test_areas_old="${areas}"
			eval `v.info -t map="${1}" layer=1`
			check_error "Failed to query map '$1' for feature count."
			fld_test_num_keys=`v.db.select -c --quiet columns="${2}" map="${1}" layer="1" | "${GREP}" -v -e '^$' -c`
			check_error "Failed to query map '$1' for contents of field '$2'."
			fld_test_num_geoms=`"${EXPR}" ${points} + ${lines} + ${areas}`
			if [ ${fld_test_num_geoms} -gt ${fld_test_num_keys} ] ; then
				RET_FLD_TEST="Field '$2' in attribute table of map '$1' is empty in one or more instances."
				# Restore previous geometry data:
				points="${fld_test_points_old}"
				lines="${fld_test_lines_old}"
				areas="${fld_test_areas_old}"
				return
			fi
			# Restore previous geometry data:
			points="${fld_test_points_old}"
			lines="${fld_test_lines_old}"
			areas="${fld_test_areas_old}"
		fi
	fi
	
	# 4. Check for uniqueness (run if at least 5 arguments given) 
	if [ $# -gt 4 ] ; then
		if [ "$5" == "TRUE" ] ; then
			FLD_TEST_KEYS=`v.db.select -c --quiet columns="${2}" map="${1}" layer="1" | "${GREP}" -v -e '^$'`
			for fld_test_key in ${FLD_TEST_KEYS} ; do
				if [ "${FLD_TEST_KEY_TYPE}" = "CHARACTER" ] || [ "${FLD_TEST_KEY_TYPE}" = "TEXT" ] ; then
					fld_test_num_matches=`v.db.select -c --quiet columns="${2}" where="${2}='$fld_test_key'" map="${1}" layer="1" | "${GREP}" -v -e '^$' -c`
					check_error "Failed to query map '$1' for contents of field '$2'."
				else
					fld_test_num_matches=`v.db.select -c --quiet columns="${2}" where="${2}=$fld_test_key" map="${1}" layer="1" | "${GREP}" -v -e '^$' -c`
					check_error "Failed to query map '$1' for contents of field '$2'."
				fi
				if [ ${fld_test_num_matches} -ne 1 ] ; then
					RET_FLD_TEST="Value '$fld_test_key' is not unique for field '$2' (${fld_test_num_matches} occurrences in attribute table of map '$1')."
					return
				fi
			done
		fi
	fi	
	
	# All ok
	RET_FLD_TEST="$2"
}


# FUNCTION
# check_error: Check last return status, issue an error message and abort if appropriate.
#
# Arguments:
#
# $1 - Error message to display (mandatory)
# $2 - PID (optional)
#
# At least $1 must be provided (error message) for this function to
# work correctly.
#
# If $2 is also provided, then its value will be interpreted as
# an integer type PID, and a 'kill' command with Signal type '1'
# will be issued to terminate the corresponding job.
#
check_error () {
	if [ ! "$?" -eq "0" ] ; then
		g.message -e "$1"
		if [ -n "${PKILL}" ] && [ -n $2 ] && [ "$2" != "" ] ; then
			# PID passed and "pkill" command available: kill this and all
			# subprocesses!
			clean_up
			g.message -e "Terminating job with PID $2 and all subprocesses."	
			"${PKILL}" --signal 9 -P $2 &
			exit ${EXIT_ERROR}
		else
			clean_up
			exit ${EXIT_ERROR}
		fi		
	fi
}


# FUNCTION
# check_input: Check input data for validity. ORDER MATTERS!
check_input () {

	# CHECK INPUT LINKS
	if [ ${GRASS_VERBOSE} -gt 0 ] ; then
		g.message -i "Verifying validity of links input map (option 'links=')..."
	fi
	#
	# 1. Test basic map properties: attribute table exists and only lines present?
	#
	eval `v.info -e map="${GIS_OPT_LINKS}" | "${GREP}" "num_dblinks="`
	if [ -z ${num_dblinks} ] ; then
		exit_error "Failed to get basic info for links vector map."
	fi
	if [ ${num_dblinks} -lt 1 ] ; then
		exit_error "Table connection for layer '1' does not exist in links map."
	fi
	eval `v.info -t map="${GIS_OPT_LINKS}" layer="1"`
	check_error "Failed to get topology info for links map."		
	if [ ${points} -gt 0 ] || [ ${boundaries} -gt 0 ] || [ ${centroids} -gt 0 ] || [ ${areas} -gt 0 ] || [ ${islands} -gt 0 ] ; then
		exit_error "Vector input map 'links' must only contain line geometries."
	fi
	if [ ${lines} -lt 1 ] ; then
		exit_error "Vector input map 'links' must contain at least one line geometry."
	fi
	#
	# Get and store attribute table info for links maps:
	get_tbl_info "${GIS_OPT_LINKS}"
	attribute_table_links="${attribute_table}"
	attribute_database_links="${attribute_database}"
	#
	# "from_id"
	check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_FROM_ID}" "INTEGER" 	"TRUE"	"FALSE"
	if [ "${RET_FLD_TEST}" != "${LINKS_FLD_FROM_ID}" ] ; then
		exit_error "${RET_FLD_TEST}"
	fi
	# "to_id"
	check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_TO_ID}" 	"INTEGER" 	"TRUE"	"FALSE"
	if [ "${RET_FLD_TEST}" != "${LINKS_FLD_TO_ID}" ] ; then
		exit_error "${RET_FLD_TEST}"
	fi
	# from_lbl
	check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_FROM_LBL}" "CHARACTER" "TRUE"	"FALSE"
	if [ "${RET_FLD_TEST}" != "${LINKS_FLD_FROM_LBL}" ] ; then
		check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_FROM_LBL}" "TEXT" 	"TRUE"	"FALSE"
		if [ "${RET_FLD_TEST}" != "${LINKS_FLD_FROM_LBL}" ] ; then
			exit_error "Field '${LINKS_FLD_FROM_LBL}' in attribute table of map '${GIS_OPT_LINKS}' is not of type 'CHARACTER' or 'TEXT'."
		fi
	fi
	# to_lbl
	check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_TO_LBL}" 	"CHARACTER" "TRUE"	"FALSE"
	if [ "${RET_FLD_TEST}" != "${LINKS_FLD_TO_LBL}" ] ; then
		check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_TO_LBL}" 	"TEXT" 	"TRUE"	"FALSE"
		if [ "${RET_FLD_TEST}" != "${LINKS_FLD_TO_LBL}" ] ; then
			exit_error "Field '${LINKS_FLD_TO_LBL}' in attribute table of map '${GIS_OPT_LINKS}' is not of type 'CHARACTER' or 'TEXT'."
		fi
	fi
	#
	# If these attributes are missing, we trigger auto-computation:
	TRIGGER_ATTR_COORDINATES="FALSE" # Rebuild all coordinates stored in attributes (from/to x/y)
	TRIGGER_ATTR_LENGTH="FALSE"
	# Coordinate fields
	num_init_valid_coord_flds=0
	# from_x
	check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_FROM_X}"
	if [ "${RET_FLD_TEST}" == "${LINKS_FLD_FROM_X}" ] ; then
		# Field exists: Check if it is ok.
		check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_FROM_X}" 	"DOUBLE PRECISION" 	"TRUE"	"FALSE"
		if [ "${RET_FLD_TEST}" != "${LINKS_FLD_FROM_X}" ] ; then
			g.message -e "Attribute field '${LINKS_FLD_FROM_X}' has wrong type or incomplete data."
			g.message -e "Please fix manually or delete ALL coordinate fields from links map to rebuild automatically."
			g.message -e "Coordinate fields are: '${LINKS_FLD_FROM_X}'/'${LINKS_FLD_FROM_Y}' and '${LINKS_FLD_TO_X}'/'${LINKS_FLD_TO_Y}'."
			exit_error "${RET_FLD_TEST}"
		else
			num_init_valid_coord_flds=`"${EXPR}" ${num_init_valid_coord_flds} + 1`
		fi
	fi
	# from_x
	check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_FROM_Y}"
	if [ "${RET_FLD_TEST}" == "${LINKS_FLD_FROM_Y}" ] ; then
		# Field exists: Check if it is ok.
		check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_FROM_Y}" 	"DOUBLE PRECISION" 	"TRUE"	"FALSE"
		if [ "${RET_FLD_TEST}" != "${LINKS_FLD_FROM_Y}" ] ; then
			g.message -e "Attribute field '${LINKS_FLD_FROM_Y}' has wrong type or incomplete data."
			g.message -e "Please fix manually or delete ALL coordinate fields from links map to rebuild automatically."
			g.message -e "Coordinate fields are: '${LINKS_FLD_FROM_X}'/'${LINKS_FLD_FROM_Y}' and '${LINKS_FLD_TO_X}'/'${LINKS_FLD_TO_Y}'."
			exit_error "${RET_FLD_TEST}"
		else
			num_init_valid_coord_flds=`"${EXPR}" ${num_init_valid_coord_flds} + 1`
		fi
	fi		
	# to_x
	check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_TO_X}"
	if [ "${RET_FLD_TEST}" == "${LINKS_FLD_TO_X}" ] ; then
		# Field exists: Check if it is ok.
		check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_TO_X}" 	"DOUBLE PRECISION" 	"TRUE"	"FALSE"
		if [ "${RET_FLD_TEST}" != "${LINKS_FLD_TO_X}" ] ; then
			g.message -e "Attribute field '${LINKS_FLD_TO_X}' has wrong type or incomplete data."
			g.message -e "Please fix manually or delete ALL coordinate fields from links map to rebuild automatically."
			g.message -e "Coordinate fields are: '${LINKS_FLD_FROM_X}'/'${LINKS_FLD_FROM_Y}' and '${LINKS_FLD_TO_X}'/'${LINKS_FLD_TO_Y}'."
			exit_error "${RET_FLD_TEST}"
		else
			num_init_valid_coord_flds=`"${EXPR}" ${num_init_valid_coord_flds} + 1`
		fi
	fi
	# to_y
	check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_TO_Y}"
	if [ "${RET_FLD_TEST}" == "${LINKS_FLD_TO_Y}" ] ; then
		# Field exists: Check if it is ok.
		check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_TO_Y}" 	"DOUBLE PRECISION" 	"TRUE"	"FALSE"
		if [ "${RET_FLD_TEST}" != "${LINKS_FLD_TO_Y}" ] ; then
			g.message -e "Attribute field '${LINKS_FLD_TO_Y}' has wrong type or incomplete data."
			g.message -e "Please fix manually or delete ALL coordinate fields from links map to rebuild automatically."
			g.message -e "Coordinate fields are: '${LINKS_FLD_FROM_X}'/'${LINKS_FLD_FROM_Y}' and '${LINKS_FLD_TO_X}'/'${LINKS_FLD_TO_Y}'."
			exit_error "${RET_FLD_TEST}"
		else
			num_init_valid_coord_flds=`"${EXPR}" ${num_init_valid_coord_flds} + 1`
		fi
	fi
	#
	# Make sure that ALL FOUR coordinate fields are valid or trigger auto-computation:
	if [ ${num_init_valid_coord_flds} -eq 0 ] ; then
		# No coordinate fields present: trigger
		if [ ${GRASS_VERBOSE} -gt 0 ] ; then		
			g.message -w "Coordinate attribute fields are missing from links map '${GIS_OPT_LINKS}'."
			g.message -w "They will be added and their contents computed automatically."
			g.message -w "Coordinate fields are: '${LINKS_FLD_FROM_X}'/'${LINKS_FLD_FROM_Y}' and '${LINKS_FLD_TO_X}'/'${LINKS_FLD_TO_Y}'."
		fi
		TRIGGER_ATTR_COORDINATES="TRUE"
	else
		if [ ${num_init_valid_coord_flds} -lt 4 ] ; then
			# At least one coord field present, but less than four valid fields: error
			g.message -e "Not all coordinate fields present or invalid coordinate field(s) found."
			g.message -e "Please fix manually or delete ALL coordinate fields from links map to rebuild automatically."
			g.message -e "Coordinate fields are: '${LINKS_FLD_FROM_X}'/'${LINKS_FLD_FROM_Y}' and '${LINKS_FLD_TO_X}'/'${LINKS_FLD_TO_Y}'."
			exit ${EXIT_ERROR}
		fi
	fi			
	# length_km: If this exists, then it must have the right type, and it must be complete!
	# If it does not exist, then it will be rebuild automatically ONLY if 'length_m' is also missing!
	check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_LEN_KM}"
	if [ "${RET_FLD_TEST}" == "${LINKS_FLD_LEN_KM}" ] ; then
		# Field exists: Check if it is ok.
		check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_LEN_KM}" 	"DOUBLE PRECISION" 	"TRUE"	"FALSE"
		if [ "${RET_FLD_TEST}" != "${LINKS_FLD_LEN_KM}" ] ; then
			g.message -e "Attribute field '${LINKS_FLD_LEN_KM}' has wrong type or incomplete data."
			g.message -e "Please fix manually or delete it AND field '${LINKS_FLD_LEN_M}' from links map to rebuild both automatically."
			exit_error "${RET_FLD_TEST}"
		fi
	fi
	# [length_m] -> ad hoc	[+length_km]
	check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_LEN_M}"
	if [ "${RET_FLD_TEST}" == "${LINKS_FLD_LEN_M}" ] ; then
		# Field exists: Check if it is ok.
		check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_LEN_M}" 	"DOUBLE PRECISION" 	"TRUE"	"FALSE"
		if [ "${RET_FLD_TEST}" != "${LINKS_FLD_LEN_M}" ] ; then
			g.message -e "Attribute field '${LINKS_FLD_LEN_M}' has wrong type or incomplete data."
			g.message -e "Please fix manually or delete field from links map to rebuild automatically."
			exit_error "${RET_FLD_TEST}"
		fi
		TRIGGER_ATTR_LENGTH="FALSE"
	else
		# Field does not exist at all: Trigger auto-computation:
		if [ ${GRASS_VERBOSE} -gt 0 ] ; then
			g.message -w "Attribute field '${LINKS_FLD_LEN_M}' is missing from links map '${GIS_OPT_LINKS}'."
			g.message -w "It will be added and its contents computed automatically."
		fi
		TRIGGER_ATTR_LENGTH="TRUE"
		# Check if field "length_km" also exists and warn if it does, because it will be re-computed:				
		check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_LEN_KM}"
		if [ "${RET_FLD_TEST}" == "${LINKS_FLD_LEN_KM}" ] ; then
			# It exists (further up, we have already made sure that it has the right type!).
			if [ ${GRASS_VERBOSE} -gt 0 ] ; then
				g.message -w "Contents of existing field '${LINKS_FLD_LEN_KM}' will also be re-computed."
			fi
		fi					
	fi
	# Set RUNMODE_COST variable depending on whether 'cost' attribute is present!
	check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_COST}"
	if [ "${RET_FLD_TEST}" == "${LINKS_FLD_COST}" ] ; then
		# Field exists: Check if it is ok.
		check_field "${GIS_OPT_LINKS}"	"${LINKS_FLD_COST}" 	"DOUBLE PRECISION" 	"TRUE"	"FALSE"
		if [ "${RET_FLD_TEST}" != "${LINKS_FLD_COST}" ] ; then
			g.message -e "Attribute field '${LINKS_FLD_COST}' has wrong type or incomplete data."
			exit_error "${RET_FLD_TEST}"
		fi
		# Cost field is ok.
		RUNMODE_COST="TRUE"
	else
		# Field does not exist at all: Trigger auto-computation:
		if [ ${GRASS_VERBOSE} -gt 0 ] ; then
			g.message -w "Attribute field '${LINKS_FLD_COST}' is missing from links map '${GIS_OPT_LINKS}'."
			g.message -w "No cost-based statistics will be computed."
		fi
		RUNMODE_COST="FALSE"
	fi

	# CHECK INPUT NODES
	#
	GIS_OPT_NODES_ORG="$GIS_OPT_NODES" # Keep a copy of original name of nodes input map
	if [ -n "${GIS_OPT_NSTATS}" ] ; then
		# GIS_OPT_NSTATS provided!
		# In that case, instead of adding/updating attribute fields in the nodes
		# input map, we work with a copy of it and then save the result as a new
		# vector map. This avoids accidental overwriting of existing data and also
		# allows external callers, such as QGIS' Processing plugin to create
		# exportable, permanent output:
		#
		# - We make a copy of the nodes input map, implicitly set the -f(orce) flag,
		#   and then set $GIS_OPT_NODES to be $GIS_OPT_NSTATS
		#
		# That way, the stats attribute fields will be added/recreated as needed
		# using a copy of the original nodes input map, instead of manipulating the
		# nodes input map itself.
		#
		# 1. Copy $GIS_OPT_NODES -> $GIS_OPT_NSTATS
		g.copy vect="${GIS_OPT_NODES}","${GIS_OPT_NSTATS}" --o --quiet 2>/dev/null
		check_error "Failed to copy input nodes map to new output nodes map (option 'nstats=')."
		# 2. Implicitly set "-f"orce flag
		GIS_FLAG_F=1
		# 3. Point GIS_OPT_NODES -> $GIS_OPT_NSTATS
		GIS_OPT_NODES="${GIS_OPT_NSTATS}"
	fi	
	
	if [ ${GRASS_VERBOSE} -gt 0 ] ; then
		g.message -i "Verifying validity of nodes input map (option 'nodes=')..."
	fi
	#
	# 1. Test basic map properties: attribute table exists and only nodes present?
	#
	eval `v.info -e map="${GIS_OPT_NODES}" | "${GREP}" "num_dblinks="`
	if [ -z ${num_dblinks} ] ; then
		exit_error "Failed to get basic info for nodes vector map."
	fi
	if [ ${num_dblinks} -lt 1 ] ; then
		exit_error "Table connection for layer '1' does not exist in nodes map."
	fi
	eval `v.info -t map="${GIS_OPT_NODES}" layer="1"`
	check_error "Failed to get topology info for nodes map."		
	if [ ${lines} -gt 0 ] || [ ${boundaries} -gt 0 ] || [ ${centroids} -gt 0 ] || [ ${areas} -gt 0 ] || [ ${islands} -gt 0 ] ; then
		exit_error "Vector input map 'nodes' must only contain point geometries."
	fi
	if [ ${points} -lt 2 ] ; then
		exit_error "Vector input map 'nodes' must contain at least two point geometries."
	fi
	NUM_INPUT_NODES=${points}
	#
	# Get and store attribute table info for nodes maps:
	get_tbl_info "${GIS_OPT_NODES}"
	attribute_table_nodes="${attribute_table}"
	attribute_database_nodes="${attribute_database}"
	#
	# Check that 'key' field is valid:
	if [ ${GRASS_VERBOSE} -gt 0 ] ; then
		g.message -i "Checking key field validity..."
	fi
	# - must exist (case sensitive, white space possible)
	result=`v.info -c --quiet map="${GIS_OPT_NODES}" layer="1" | ${CUT} -f 2 -d "|" | "${GREP}" "${GIS_OPT_KEY}" -w`
	if [ "${result}" != "${GIS_OPT_KEY}" ] ; then
		exit_error "Chosen 'key' field '${GIS_OPT_KEY}' does not exist in input nodes map (option 'key=')."
	fi
	# - must contain data for each feature (=${points})
	num_keys=`v.db.select -c --quiet columns="${GIS_OPT_KEY}" map="${GIS_OPT_NODES}" layer="1" | "${GREP}" -v -e '^$' -c`
	check_error "Key field (option 'key=') is not valid."
	if [ ${points} -ne ${num_keys} ] ; then
		exit_error "Number of primary key records (option 'key=') does not match number of input nodes (${num_keys} keys vs ${points} nodes)."
	fi
	# - must be of type INTEGER
	result=`v.info -c --quiet map="${GIS_OPT_NODES}" layer="1" | "${GREP}" "INTEGER|${GIS_OPT_KEY}" -w -c`
	if [ ${result} -ne 1 ] ; then
		exit_error "Type of 'key' field in input nodes layer is not 'integer' (option 'key=')."
	fi
	# - must be UNIQUE for each feature: We us sort's abiliity to remove duplicate lines after sorting.
	#   At the same time, this will make sure that empty field values will be discarded.
	count_total=`v.db.select -c --quiet columns="${GIS_OPT_KEY}" map="${GIS_OPT_NODES}" layer="1" | ${SORT} | ${WC} -l`
	count_unique=`v.db.select -c --quiet columns="${GIS_OPT_KEY}" map="${GIS_OPT_NODES}" layer="1" | ${SORT} -u | ${WC} -l`
	# If number of unique lines after sorting key list != total number of lines: We have duplicates!
	if [ ${count_unique} -ne ${count_total} ] ; then
		exit_error "Primary key column '$key' does not contain unique data, (only $count_unique of $count_total values are unique)."
	fi
	# If number of lines != number of input nodes: We have empty values!
	if [ ${NUM_INPUT_NODES} -ne ${count_total} ] ; then
		exit_error "Primary key column '$key' does not contain as many values as there are input nodes, (only $count_total values present)."
	fi
	# - must not be the same as GRASS primary key for this layer
	cmd=`v.info -e map="${GIS_OPT_NODES}"`	
	check_error "Failed to query (filtered) input nodes layer for extended metadata."
	eval_ws_safe "${cmd}" "attribute_primary_key"
	if [ "${EVAL_RESULT}" = "${GIS_OPT_KEY}" ] ; then
		exit_error "Name of 'key' field ('$key') is the same as GRASS primary key of input nodes layer (option 'key=')."
	fi
	#
	# Check whether node statistics fields are already present in NODES input map.
	# 'links' (INTEGER)
	fld=`v.info map="${GIS_OPT_NODES}" layer="1" --quiet -c | "${GREP}" -i -w "${NODES_FLD_LINKS}"`
	if [ -n "${fld}" ] ; then
		if [ ${GIS_FLAG_F} -eq 1 ] ; then
			# Field exists and -f flag given: Drop field and re-create it with correct type (INTEGER) if necessary.
			fld_test_result=`v.info -c --quiet map="${GIS_OPT_NODES}" layer="1" | "${GREP}" "INTEGER|${NODES_FLD_LINKS}" -w -c`
			if [ ${fld_test_result} -ne 1 ] ; then
				# Field is not of correct type: Drop and re-create it!
				if [ -z "${GIS_OPT_NSTATS}" ] ; then
					g.message -w "Found attribute with reserved field name '${NODES_FLD_LINKS}' but wrong type."
					g.message -w "Field will be dropped and re-created with correct type (INTEGER)."				
				fi
				${V_DB_DROPCOLUMN} layer="1" map="${GIS_OPT_NODES}" columns="${NODES_FLD_LINKS}" --quiet
				check_error "Failed to remove reserved attribute '${NODES_FLD_LINKS}' from input nodes map '${GIS_OPT_NODES}'."
				${V_DB_ADDCOLUMN} map="${GIS_OPT_NODES}" layer="1" columns="${NODES_FLD_LINKS} INTEGER" --quiet
				check_error "Failed to add attribute field '${NODES_FLD_LINKS}' to nodes input map '${GIS_OPT_NODES}'."
			fi
		else
			# Field exists and -f not given: Abort!
			if [ ${GRASS_VERBOSE} -gt 0 ] ; then
				g.message -i "Found attribute with reserved field name '${NODES_FLD_LINKS}' in nodes input map '${GIS_OPT_NODES}'."
				g.message -i "Set '-f'(orce) flag to overwrite."
			fi
			exit_error "Nodes statistics field '${NODES_FLD_LINKS}' present in input map and '-f'(orce) flag not set."
		fi
	else
		# Field does not yet exist: Create it!
		${V_DB_ADDCOLUMN} map="${GIS_OPT_NODES}" layer="1" columns="${NODES_FLD_LINKS} INTEGER" --quiet
		check_error "Failed to add attribute field '${NODES_FLD_LINKS}' to nodes input map '${GIS_OPT_NODES}'."
	fi
	# 'len_sum' (DOUBLE PRECISION)
	fld=`v.info map="${GIS_OPT_NODES}" layer="1" --quiet -c | "${GREP}" -i -w "${NODES_FLD_LEN_SUM}"`
	if [ -n "${fld}" ] ; then
		if [ ${GIS_FLAG_F} -eq 1 ] ; then
			# Field exists and -f flag given: Drop field and re-create it with correct type (DOUBLE PRECISION) if necessary.
			fld_test_result=`v.info -c --quiet map="${GIS_OPT_NODES}" layer="1" | "${GREP}" "DOUBLE PRECISION|${NODES_FLD_LEN_SUM}" -w -c`
			if [ ${fld_test_result} -ne 1 ] ; then
				# Field is not of correct type: Drop and re-create it!			
				if [ -z "${GIS_OPT_NSTATS}" ] ; then	
					g.message -w "Found attribute with reserved field name '${NODES_FLD_LEN_SUM}' but wrong type."
					g.message -w "Field will be dropped and re-created with correct type (DOUBLE PRECISION)."				
				fi
				${V_DB_DROPCOLUMN} layer="1" map="${GIS_OPT_NODES}" columns="${NODES_FLD_LEN_SUM}" --quiet
				check_error "Failed to remove reserved attribute '${NODES_FLD_LEN_SUM}' from input nodes map '${GIS_OPT_NODES}'."
				${V_DB_ADDCOLUMN} map="${GIS_OPT_NODES}" layer="1" columns="${NODES_FLD_LEN_SUM} DOUBLE PRECISION" --quiet
				check_error "Failed to add attribute field '${NODES_FLD_LEN_SUM}' to nodes input map '${GIS_OPT_NODES}'."
			fi
		else
			# Field exists and -f not given: Abort!
			if [ ${GRASS_VERBOSE} -gt 0 ] ; then
				g.message -i "Found attribute with reserved field name '${NODES_FLD_LEN_SUM}' in nodes input map '${GIS_OPT_NODES}'."
				g.message -i "Set '-f'(orce) flag to overwrite."
			fi
			exit_error "Nodes statistics field '${NODES_FLD_LEN_SUM}' present in input map and '-f'(orce) flag not set."
		fi
	else
		# Field does not yet exist: Create it!
		${V_DB_ADDCOLUMN} map="${GIS_OPT_NODES}" layer="1" columns="${NODES_FLD_LEN_SUM} DOUBLE PRECISION" --quiet
		check_error "Failed to add attribute field '${NODES_FLD_LEN_SUM}' to nodes input map '${GIS_OPT_NODES}'."
	fi
	# 'len_mean' (DOUBLE PRECISION)
	fld=`v.info map="${GIS_OPT_NODES}" layer="1" --quiet -c | "${GREP}" -i -w "${NODES_FLD_LEN_AVG}"`
	if [ -n "${fld}" ] ; then
		if [ ${GIS_FLAG_F} -eq 1 ] ; then
			# Field exists and -f flag given: Drop field and re-create it with correct type (DOUBLE PRECISION) if necessary.
			fld_test_result=`v.info -c --quiet map="${GIS_OPT_NODES}" layer="1" | "${GREP}" "DOUBLE PRECISION|${NODES_FLD_LEN_AVG}" -w -c`
			if [ ${fld_test_result} -ne 1 ] ; then
				# Field is not of correct type: Drop and re-create it!
				if [ -z "${GIS_OPT_NSTATS}" ] ; then		
					g.message -w "Found attribute with reserved field name '${NODES_FLD_LEN_AVG}' but wrong type."
					g.message -w "Field will be dropped and re-created with correct type (DOUBLE PRECISION)."				
				fi
				${V_DB_DROPCOLUMN} layer="1" map="${GIS_OPT_NODES}" columns="${NODES_FLD_LEN_AVG}" --quiet
				check_error "Failed to remove reserved attribute '${NODES_FLD_LEN_AVG}' from input nodes map '${GIS_OPT_NODES}'."
				${V_DB_ADDCOLUMN} map="${GIS_OPT_NODES}" layer="1" columns="${NODES_FLD_LEN_AVG} DOUBLE PRECISION" --quiet
				check_error "Failed to add attribute field '${NODES_FLD_LEN_AVG}' to nodes input map '${GIS_OPT_NODES}'."
			fi
		else
			# Field exists and -f not given: Abort!
			if [ ${GRASS_VERBOSE} -gt 0 ] ; then
				g.message -i "Found attribute with reserved field name '${NODES_FLD_LEN_AVG}' in nodes input map '${GIS_OPT_NODES}'."
				g.message -i "Set '-f'(orce) flag to overwrite."
			fi
			exit_error "Nodes statistics field '${NODES_FLD_LEN_AVG}' present in input map and '-f'(orce) flag not set."
		fi
	else
		# Field does not yet exist: Create it!
		${V_DB_ADDCOLUMN} map="${GIS_OPT_NODES}" layer="1" columns="${NODES_FLD_LEN_AVG} DOUBLE PRECISION" --quiet
		check_error "Failed to add attribute field '${NODES_FLD_LEN_AVG}' to nodes input map '${GIS_OPT_NODES}'."
	fi
	# Further attribute fields for cost-based statistics:
	if [ "${RUNMODE_COST}" == "TRUE" ] ; then
		# 'cost_sum' (DOUBLE PRECISION)
		fld=`v.info map="${GIS_OPT_NODES}" layer="1" --quiet -c | "${GREP}" -i -w "${NODES_FLD_COST_SUM}"`
		if [ -n "${fld}" ] ; then
			if [ ${GIS_FLAG_F} -eq 1 ] ; then
				# Field exists and -f flag given: Drop field and re-create it with correct type (DOUBLE PRECISION) if necessary.
				fld_test_result=`v.info -c --quiet map="${GIS_OPT_NODES}" layer="1" | "${GREP}" "DOUBLE PRECISION|${NODES_FLD_COST_SUM}" -w -c`
				if [ ${fld_test_result} -ne 1 ] ; then
					# Field is not of correct type: Drop and re-create it!
					if [ -z "${GIS_OPT_NSTATS}" ] ; then
						g.message -w "Found attribute with reserved field name '${NODES_FLD_COST_SUM}' but wrong type."
						g.message -w "Field will be dropped and re-created with correct type (DOUBLE PRECISION)."
					fi
					${V_DB_DROPCOLUMN} layer="1" map="${GIS_OPT_NODES}" columns="${NODES_FLD_COST_SUM}" --quiet
					check_error "Failed to remove reserved attribute '${NODES_FLD_COST_SUM}' from input nodes map '${GIS_OPT_NODES}'."
					${V_DB_ADDCOLUMN} map="${GIS_OPT_NODES}" layer="1" columns="${NODES_FLD_COST_SUM} DOUBLE PRECISION" --quiet
					check_error "Failed to add attribute field '${NODES_FLD_COST_SUM}' to nodes input map '${GIS_OPT_NODES}'."
				fi
			else
				# Field exists and -f not given: Abort!
				if [ ${GRASS_VERBOSE} -gt 0 ] ; then
					g.message -i "Found attribute with reserved field name '${NODES_FLD_COST_SUM}' in nodes input map '${GIS_OPT_NODES}'."
					g.message -i "Set '-f'(orce) flag to overwrite."
				fi
				exit_error "Nodes statistics field '${NODES_FLD_COST_SUM}' present in input map and '-f'(orce) flag not set."
			fi
		else
			# Field does not yet exist: Create it!
			${V_DB_ADDCOLUMN} map="${GIS_OPT_NODES}" layer="1" columns="${NODES_FLD_COST_SUM} DOUBLE PRECISION" --quiet
			check_error "Failed to add attribute field '${NODES_FLD_COST_SUM}' to nodes input map '${GIS_OPT_NODES}'."
		fi
		# 'cost_mean' (DOUBLE PRECISION)
		fld=`v.info map="${GIS_OPT_NODES}" layer="1" --quiet -c | "${GREP}" -i -w "${NODES_FLD_COST_AVG}"`
		if [ -n "${fld}" ] ; then
			if [ ${GIS_FLAG_F} -eq 1 ] ; then
				# Field exists and -f flag given: Drop field and re-create it with correct type (DOUBLE PRECISION) if necessary.
				fld_test_result=`v.info -c --quiet map="${GIS_OPT_NODES}" layer="1" | "${GREP}" "DOUBLE PRECISION|${NODES_FLD_COST_AVG}" -w -c`
				if [ ${fld_test_result} -ne 1 ] ; then
					# Field is not of correct type: Drop and re-create it!
					if [ -z "${GIS_OPT_NSTATS}" ] ; then
						g.message -w "Found attribute with reserved field name '${NODES_FLD_COST_AVG}' but wrong type."
						g.message -w "Field will be dropped and re-created with correct type (DOUBLE PRECISION)."
					fi
					${V_DB_DROPCOLUMN} layer="1" map="${GIS_OPT_NODES}" columns="${NODES_FLD_COST_AVG}" --quiet
					check_error "Failed to remove reserved attribute '${NODES_FLD_COST_AVG}' from input nodes map '${GIS_OPT_NODES}'."
					${V_DB_ADDCOLUMN} map="${GIS_OPT_NODES}" layer="1" columns="${NODES_FLD_COST_AVG} DOUBLE PRECISION" --quiet
					check_error "Failed to add attribute field '${NODES_FLD_COST_AVG}' to nodes input map '${GIS_OPT_NODES}'."
				fi
			else
				# Field exists and -f not given: Abort!
				if [ ${GRASS_VERBOSE} -gt 0 ] ; then
					g.message -i "Found attribute with reserved field name '${NODES_FLD_COST_AVG}' in nodes input map '${GIS_OPT_NODES}'."
					g.message -i "Set '-f'(orce) flag to overwrite."
				fi
				exit_error "Nodes statistics field '${NODES_FLD_COST_AVG}' present in input map and '-f'(orce) flag not set."
			fi
		else
			# Field does not yet exist: Create it!
			${V_DB_ADDCOLUMN} map="${GIS_OPT_NODES}" layer="1" columns="${NODES_FLD_COST_AVG} DOUBLE PRECISION" --quiet
			check_error "Failed to add attribute field '${NODES_FLD_COST_AVG}' to nodes input map '${GIS_OPT_NODES}'."
		fi		
	fi
	# From this point forward, we can rely on the presence of all required node statistics fields
	# and their correct types!
	
	if [ ${GIS_FLAG_S} -eq 1 ] ; then
	    # Skipping consistency checks.
	    if [ ${GRASS_VERBOSE} -gt 2 ] ; then
			g.message -i "Consistency checks skipped. Some statistics might be faulty."
		fi
	else
		# CHECK INPUT LINKS IN RELATION TO INPUT NODES	
		#
		# 1. Check that links and nodes MATCH. The aim is to prevent users from
		#    using an links map computed for a different set of input nodes.
		#   
		# First check that all nodes in $GIS_OPT_NODES are connected to at least
		# one link in $GIS_OPT_LINKS via the from_id/to_id fields.
		# If not, then we issue a warning, since the presence of unconnected nodes
		# is not harmful.
		if [ ${GRASS_VERBOSE} -gt 0 ] ; then
			g.message -i "Checking connections of input nodes with input links (1/3):"
		fi
		# Get attribute table info:
		get_tbl_info "${GIS_OPT_LINKS}"
		attribute_database_driver_links="$attribute_database_driver"
		attribute_database_links="$attribute_database"
		attribute_table_links="$attribute_table"
		get_tbl_info "${GIS_OPT_NODES}"
		attribute_database_driver_nodes="$attribute_database_driver"
		attribute_database_nodes="$attribute_database"
		attribute_table_nodes="$attribute_table"
		#
		get_primary_keys "${GIS_OPT_NODES}"
		OLD_IFS="$IFS"
		IFS="${IFS_NEWLINE}"
		i=0
		for key in ${PRIMARY_KEYS} ; do
			if [ -n $BASH_VERSION ] ; then
				let i=${i}+1
			else
				i=`"${EXPR}" ${i} + 1`
			fi
		done
		max=${i}
		i=0
		for key in ${PRIMARY_KEYS} ; do
			# Step through all input nodes and count number of connections:
			num_connections_from=`db.select database="${attribute_database_links}" sql="SELECT ${LINKS_FLD_FROM_ID} FROM ${attribute_table_links} WHERE ${LINKS_FLD_FROM_ID}=$key;" driver="$attribute_database_driver_links" -c --quiet | "${GREP}" "${key}" -c`
			if [ -z "${num_connections_from}" ] ; then
				num_connections_from=0
			fi
			num_connections_to=`db.select database="${attribute_database_links}" sql="SELECT ${LINKS_FLD_TO_ID} FROM ${attribute_table_links} WHERE ${LINKS_FLD_TO_ID}=$key;" driver="$attribute_database_driver_links" -c --quiet | "${GREP}" "${key}" -c`
			if [ -z "${num_connections_to}" ] ; then
				num_connections_to=0
			fi
			if [ -n $BASH_VERSION ] ; then
				let num_connections_total=${num_connections_from}+${num_connections_to}
			else
				num_connections_total=`"${EXPR}" ${num_connections_from} + ${num_connections_to}`
			fi
			if [ ${num_connections_total} -lt 1 ] ; then
				if [ ${GRASS_VERBOSE} -gt 0 ] ; then
					g.message -w "Node with primary key '${GIS_OPT_KEY}=${key}' is unconnected in links map."
				fi
			fi
			if [ -n $BASH_VERSION ] ; then
				let i=${i}+1
			else
				i=`"${EXPR}" ${i} + 1`
			fi
			if [ ${GRASS_VERBOSE} -gt 0 ] ; then
				g.message -p "${i} ${max} 1"
			fi
		done
		IFS="${OLD_IFS}"
		
		# Now the other way around: we traverse all from/to ID fields in links map
		# and check if there are two corresponding nodes in GIS_OPT_NODES.
		# If NOT, then we have a FATAL ERROR.
		if [ ${GRASS_VERBOSE} -gt 0 ] ; then
			g.message -i "Checking connections of input nodes with input links (2/3):"
		fi
		get_grass_cats "${GIS_OPT_LINKS}"
		OLD_IFS="$IFS"
		IFS="${IFS_NEWLINE}"
		i=0
		for cat in ${GRASS_CATS} ; do
			if [ -n $BASH_VERSION ] ; then
				let i=${i}+1
			else
				i=`"${EXPR}" ${i} + 1`
			fi
		done
		# Check all from_id fields:
		max=${i}
		i=0
		for cat in ${GRASS_CATS} ; do
			# Get value of 'from_id' for this link:
			init_from_id=`db.select database="${attribute_database_links}" sql="SELECT ${LINKS_FLD_FROM_ID} FROM ${attribute_table_links} WHERE ${GRASS_PKEY}=${cat};" driver="$attribute_database_driver_links" -c --quiet`
			check_error "Failed to retrieve value of field ('${LINKS_FLD_FROM_ID}') from links input map ('${GRASS_PKEY}=${cat}')."
			# Check if 'from_id' occurs as primary key of any input node:
			num_connections_from=`db.select database="${attribute_database_nodes}" sql="SELECT ${GIS_OPT_KEY} FROM ${attribute_table_nodes} WHERE ${GIS_OPT_KEY}=${init_from_id};" driver="$attribute_database_driver_nodes" -c --quiet | "${GREP}" "${init_from_id}" -c`
			if [ -z "${num_connections_from}" ] ; then
				num_connections_from=0
			fi
			# Get value of 'to_id' for this link:		
			init_to_id=`db.select database="${attribute_database_links}" sql="SELECT ${LINKS_FLD_TO_ID} FROM ${attribute_table_links} WHERE ${GRASS_PKEY}=${cat};" driver="$attribute_database_driver_links" -c --quiet`
			check_error "Failed to retrieve value of field ('${LINKS_FLD_TO_ID}') from links input map ('${GRASS_PKEY}=${cat}')."
			# Check if 'to_id' occurs as primary key of any input node:
			num_connections_to=`db.select database="${attribute_database_nodes}" sql="SELECT ${GIS_OPT_KEY} FROM ${attribute_table_nodes} WHERE ${GIS_OPT_KEY}=${init_to_id};" driver="$attribute_database_driver_nodes" -c --quiet | "${GREP}" "${init_to_id}" -c`
			if [ -z "${num_connections_to}" ] ; then
				num_connections_to=0
			fi
			if [ -n $BASH_VERSION ] ; then
				let num_connections_total=${num_connections_from}+${num_connections_to}
			else
				num_connections_total=`"${EXPR}" ${num_connections_from} + ${num_connections_to}`
			fi
			if [ ${num_connections_total} -lt 2 ] ; then				
				exit_error "Initial link with primary key '${GRASS_PKEY}=${cat}' is not connected to two nodes in input map. Hint: Check extents of GRASS region (must completely contain links)."				
			fi
			if [ -n $BASH_VERSION ] ; then
				let i=${i}+1
			else
				i=`"${EXPR}" ${i} + 1`
			fi
			if [ ${GRASS_VERBOSE} -gt 0 ] ; then
				g.message -p "${i} ${max} 1"
			fi
		done
		IFS="${OLD_IFS}"	
		#
		# 2. Check that the same two nodes are not linked more than once in links map:
		#
		if [ ${GRASS_VERBOSE} -gt 0 ] ; then
			g.message -i "Checking connections of input nodes with input links (3/3):"
		fi
		get_grass_cats "${GIS_OPT_LINKS}"
		i=0
		OLD_IFS="$IFS"
		IFS="${IFS_NEWLINE}"
		for cat in ${GRASS_CATS} ; do
			if [ -n $BASH_VERSION ] ; then
				let i=${i}+1
			else
				i=`"${EXPR}" ${i} + 1`
			fi
		done
		max=${i}
		i=0
		for cat in ${GRASS_CATS} ; do
			init_from_id=`db.select database="${attribute_database_links}" sql="SELECT ${LINKS_FLD_FROM_ID} FROM ${attribute_table_links} WHERE ${GRASS_PKEY}=${cat};" driver="$attribute_database_driver_links" -c --quiet`
			check_error "Failed to retrieve value for field ('${LINKS_FLD_FROM_ID}') from links input map."
			init_to_id=`db.select database="${attribute_database_links}" sql="SELECT ${LINKS_FLD_TO_ID} FROM ${attribute_table_links} WHERE ${GRASS_PKEY}=${cat};" driver="$attribute_database_driver_links" -c --quiet`		
			check_error "Failed to retrieve value for field ('${LINKS_FLD_TO_ID}') from links input map."
			# Check for occurrences of this from/to pair:
			num_init_pairs_ft=`db.select database="${attribute_database_links}" sql="SELECT ${LINKS_FLD_FROM_ID} FROM ${attribute_table_links} WHERE ${LINKS_FLD_FROM_ID}=${init_from_id} AND ${LINKS_FLD_TO_ID}=${init_to_id};" driver="$attribute_database_driver_links" -c --quiet | "${GREP}" "${init_from_id}" -c`
			# Check for occurrences of this to/from pair:
			num_init_pairs_tf=`db.select database="${attribute_database_links}" sql="SELECT ${LINKS_FLD_FROM_ID} FROM ${attribute_table_links} WHERE ${LINKS_FLD_FROM_ID}=${init_to_id} AND ${LINKS_FLD_TO_ID}=${init_from_id};" driver="$attribute_database_driver_links" -c --quiet | "${GREP}" "${init_from_id}" -c`
			if [ -n $BASH_VERSION ] ; then
				let num_init_pairs=${num_init_pairs_ft}+${num_init_pairs_tf}
			else
				num_init_pairs=`"${EXPR}" ${num_init_pairs_ft} + ${num_init_pairs_tf}`
			fi
			if [ $num_init_pairs -gt 1 ] ; then
				exit_error "At least one pair of nodes connected by more than one link in links map."
			fi
			if [ ${GRASS_VERBOSE} -gt 0 ] ; then
				g.message -p "${i} ${max} 1"
			fi
			if [ -n $BASH_VERSION ] ; then
				let i=${i}+1
			else
				i=`"${EXPR}" ${i} + 1`
			fi
		done # Checking map passed as "links="
		IFS="${OLD_IFS}"
	fi
	
	if [ ${GRASS_VERBOSE} -gt 2 ] ; then
		g.message -i "Input data has passed all validity checks."
	fi
}


# FUNCTION
# check_warn: Check last return status, issue a warning message if appropriate.
check_warn () {
	if [ ! "$?" -eq "0" ] ; then
		if [ ${GRASS_VERBOSE} -gt 0 ] ; then
			g.message -w "$1"
		fi
	fi
}


# FUNCTION
# exit_error: Display an error message and exit with default error code.
# 
# Arguments:
#
# $1 - Error message to display (mandatory)
# $2 - PID (optional)
#
# At least $1 must be provided (error message) for this function to
# work correctly.
#
# If $2 is also provided, then its value will be interpreted as
# an integer type PID, and a 'kill' command with Signal type '1'
# will be issued to terminate the corresponding job.
#
exit_error () {
	g.message -e "$1"	
	if [ -n $2 ] && [ "$2" != "" ] ; then
	    # PID passed: kill!
	    # Note: The trap set at the beginning of this script will make
	    # sure that all clean-up functions are run.
	    g.message -e "Terminating job with PID $2."
		#kill -s 1 $2
		clean_up
		exit ${EXIT_ERROR}
	else
		clean_up
		exit ${EXIT_ERROR}
	fi	
}


# FUNCTION
# eval_ws_safe:  White-space resilient setting of variables from command output.
#                This is useful for many GRASS commands that produce shell style
#				  output (like 'g.region -pg') of the form:
#                   var1=abc
#                   var2=123
#                   ...
#                Pass string with a command's full output as $1.
#                Pass name of a variable to set from output as $2.
#                This function will then grep the _first_ occurrence
#                of the variable name (case sensitive!) from the command output
#                and set it to the value following "=" (equal sign).
#				  As opposed to a simple 'eval', this function is able
#                to correctly set variable values that contain whitespace!
#				  This is also the safer option to use if an 'eval' statement would
#                potentially encounter values with white space for variables other
#			 	  than the target variable.
#                The contents for setting the variable are returend in "EVAL_RESULT".
eval_ws_safe () {
	OLD_IFS_EVAL_WS_SAFE="$IFS"
	IFS="${IFS_NEWLINE}"
	# Process (list of) input line(s):
	str=`"${ECHO}" "$1" | "${GREP}" "$2="`
	for i in $str
	do
		IFS="="
		CUR=$i
		for j in $CUR
		do			
			EVAL_RESULT="$j"
		done
	done	
	IFS="$OLD_IFS_EVAL_WS_SAFE"
}


# FUNCTION
# get_interpreter: 		Runs a lot of code in an attempt to accurately determine
#						the interpreter that is currently running this script.
#						It is not guaranteed that the interpreter is the same as
#						the login shell or user default shell. Thus, reading typical
#						environment variables is pretty pointless.
#						The code in this function has been taken from:
#						
#						https://www.in-ulm.de/~mascheck/various/whatshell/
#
#						Originally, it was designed to echo the name of the running
#						interpreter to the terminal.
#
#						Within this script it is used to read the interpreter's name
#						into a variable for further analysis:
#
#						interpreter=`get_interpreter`
#						
get_interpreter () {
'echo' +"'\
@ goto dos \
[exit[if {[lsearch -exact [package names] Expect]>=0} {puts expect\ [\
package require Expect]\ (Tcl\ [info patchlevel])} elseif {[lsearch -exact [\
package names] Tk]>=0} {puts wish\ (Tcl\ [info patchlevel],\ Tk\ [package \
require Tk])} else {puts tcl\ [info patchlevel]}]]' >/dev/null ' {\">/dev/null \
">"/dev/null" +"\'";q='''=.q,';q=%[\"
echo ">/dev/null;status=0;@ {status=1};*=(" '$' ");~ $status 1&&{e='"\
"';eval catch $2 ^'&version {eval ''echo <='^ $2 ^'&version''}';exit};e='"\
"';if (eval '{let ''a^~a''} >[2] /dev/null'){e='"\
"';exec echo akanga};eval exec echo rc $2 ^ version;\" > /dev/null
: #;echo possibly pre-Bourne UNIX V1-6 shell;exit
if { bindkey >& /dev/null } then
exec echo $version
else
exec echo csh
endif
: dos
@echo off
cls
echo %OS% %COMSPEC%
goto fin
", unless eval 'printf "perl %vd\n",$^V;exit;'> "/dev/null";eval ': "\'';
=S"'
: 'This script aims at recognizing all Bourne compatible shells.
   Emphasis is on shells without any version variables.
   Please comment to mascheck@in-ulm.de'
: '$Id: whatshell.sh,v 1.26 2018/02/18 23:38:06 xmascheck Exp xmascheck $'
: 'fixes are tracked on www.in-ulm.de/~mascheck/various/whatshell/'

LC_ALL=C; export LC_ALL
: 'trivial cases first, yet parseable for historic shells'
case $BASH_VERSION in *.*) { echo "bash $BASH_VERSION";exit;};;esac
case $ZSH_VERSION  in *.*) { echo "zsh $ZSH_VERSION";exit;};;esac
case "$VERSION" in *zsh*) { echo "$VERSION";exit;};;esac
case  "$SH_VERSION" in *PD*) { echo "$SH_VERSION";exit;};;esac
case "$KSH_VERSION" in *PD*|*MIRBSD*) { echo "$KSH_VERSION";exit;};;esac
case "$POSH_VERSION" in 0.[1234]|0.[1234].*) \
     { echo "posh $POSH_VERSION, possibly slightly newer, yet<0.5";exit;}
  ;; *.*|*POSH*) { echo "posh $POSH_VERSION";exit;};; esac
case $YASH_VERSION in *.*) { echo "yash $YASH_VERSION";exit;};;esac

: 'traditional Bourne shell'
(eval ': $(:)') 2>/dev/null || {
  case `(:^times) 2>&1` in *0m*):;;
    *)p=' (and pipe check for Bourne shell failed)';;esac
  : 'pre-SVR2: no functions, no echo built-in.'
  (eval 'f(){ echo :; };f') >/dev/null 2>&1 || {
    ( eval '# :' ) 2>/dev/null || { echo '7th edition Bourne shell'"$p";exit;}
    ( : ${var:=value} ) 2>/dev/null ||
    { echo '7th edition Bourne shell, # comments (BSD, or port)'"$p";exit;}
    set x x; shift 2;test "$#" != 0 && { echo 'System III Bourne shell'"$p";exit;}
    { echo 'SVR1 Bourne shell'"$p";exit;}
  }
}; : 'keep syntactical block small for pre-SVR2'

myex(){ echo "$@";exit;} # "exec echo" might call the external command

(eval ': $(:)') 2>/dev/null || {
  (set -m; set +m) 2>/dev/null && {
    priv=0;(priv work)>/dev/null 2>&1 &&
      case `(priv work)2>&1` in *built*|*found*) priv=1;;esac
    read_r=0;(echo|read -r dummy 2>/dev/null) && read_r=1
    a_read=0;unset var;set -a;read var <&-;case `export` in
       *var*) a_read=1;;esac
    case_in=0;(eval 'case x in in) :;;esac')2>/dev/null && case_in=1
    ux=0;a=`(notexistent_cmd) 2>&1`; case $a in *UX*) ux=1;;esac
    case $priv$ux$read_r$a_read$case_in in
       11110) myex 'SVR4.2 MP2 Bourne shell'
    ;; 11010) myex 'SVR4.2 Bourne shell'
    ;; 10010|01010) myex 'SVR4.x Bourne shell (between 4.0 and 4.2)'
    ;; 00111) myex 'SVR4 Bourne shell (SunOS 5 schily variant, before 2016-02-02)'
    ;; 00101) myex 'SVR4 Bourne shell (SunOS 5 heirloom variant)'
    ;; 00001) myex 'SVR4 Bourne shell (SunOS 5 variant)'
    ;; 00000) myex 'SVR4.0 Bourne shell'
    ;; *)     myex 'unknown SVR4 Bourne shell variant' ;;esac
  }
  r=0; case `(read) 2>&1` in *"missing arguments"*) r=1;;esac
  g=0; (set -- -x; getopts x var) 2>/dev/null && g=1
  case $r$g in
     11) myex 'SVR3 Bourne shell'
  ;; 10) myex 'SVR3 Bourne shell (but getopts built-in is missing)'
  ;; 01) myex 'SVR3 Bourne shell (but read built-in does not match)'
  ;; 00) (builtin :) >/dev/null 2>&1 &&
 	myex '8th edition (SVR2) Bourne shell'"$p"
 	(type :) >/dev/null 2>&1 && myex 'SVR2 Bourne shell'"$p" ||
 	myex 'SVR2 shell (but type built-in is missing)'"$p"
  ;;esac
}

case $( (:^times) 2>&1) in *0m*)
  case `eval '(echo $((1+1))) 2>/dev/null'` in
    2) myex 'SVR4 Bourne shell (SunOS 5 schily variant, posix-like, since 2016-05-24)'
  ;;*) myex 'SVR4 Bourne shell (SunOS 5 schily variant, since 2016-02-02, before 2016-05-24)'
  ;;esac
;;esac

type -F >/dev/null 2>&1 &&
  myex 'SVR4 Bourne shell (SunOS 5 schily variant, since 2016-08-08, in posix mode)'

# Almquist shell aka ash
(typeset -i var) 2>/dev/null || {
  case $SHELLVERS in "ash 0.2") myex 'original ash';;esac
  test "$1" = "debug" && debug=1
  n=1; case `(! :) 2>&1` in *not*) n=0;;esac
  b=1; case `echo \`:\` ` in '`:`') b=0;;esac
  g=0; { set -- -x; getopts x: var
         case $OPTIND in 2) g=1;;esac;} >/dev/null 2>&1
  p=0; (eval ': ${var#value}') 2>/dev/null && p=1
  r=0; ( (read</dev/null)) 2>/dev/null; case $? in 0|1|2)
	  var=`(read</dev/null)2>&1`; case $var in *arg*) r=1;;esac
	;;esac
  v=1; set x; case $10 in x0) v=0;;esac
  t=0; (PATH=;type :) >/dev/null 2>&1 && t=1
  test -z "$debug" || echo debug '$n$b$g$p$r$v$t: ' $n$b$g$p$r$v$t
  case $n$b$g$p$r$v$t in
     00*) myex 'early ash (4.3BSD, 386BSD 0.0-p0.2.3/NetBSD 0.8)'
  ;; 010*) myex 'early ash (ash-0.2 port, Slackware 2.1-8.0,'\
	'386BSD p0.2.4, NetBSD 0.9)'
  ;; 1110100) myex 'early ash (Minix 2.x-3.1.2)'
  ;; 1000000) myex 'early ash (4.4BSD Alpha)'
  ;; 1100000) myex 'early ash (4.4BSD)'
  ;; 11001*) myex 'early ash (4.4BSD Lite, early NetBSD 1.x, BSD/OS 2.x)'
  ;; 1101100) myex 'early ash (4.4BSD Lite2, BSD/OS 3 ff)'
  ;; 1101101) myex 'ash (FreeBSD -10.x, Cygwin pre-1.7, Minix 3.1.3 ff)'
  ;; 1111101) myex 'ash (FreeBSD 11.0 ff)'
  ;; esac
  e=0; case `(PATH=;exp 0)2>&1` in 0) e=1;;esac
  n=0; case y in [^x]) n=1;;esac
  r=1; case `(PATH=;noexist 2>/dev/null) 2>&1` in
        *not*) r=0 ;; *file*) r=2 ;;esac
  f=0; case `eval 'for i in x;{ echo $i;}' 2>/dev/null` in x) f=1;;esac
  test -z "$debug" || echo debug '$e$n$r$a$f: ' $e$n$r$a$f
  case $e$n$r$f in
     1100) myex 'ash (dash 0.3.8-30 - 0.4.6)'
  ;; 1110) myex 'ash (dash 0.4.7 - 0.4.25)'
  ;; 1010) myex 'ash (dash 0.4.26 - 0.5.2)'
  ;; 0120|1120|0100) myex 'ash (Busybox 0.x)'
  ;; 0110) myex 'ash (Busybox 1.x)'
  ;;esac
  a=0; case `eval 'x=1;(echo $((x)) )2>/dev/null'` in 1) a=1;;esac
  x=0; case `f(){ echo $?;};false;f` in 1) x=1;;esac
  c=0; case `echo -e '\x'` in *\\x) c=1;;esac
  test -z "$debug" || echo debug '$e$n$r$f$a$x$c: ' $e$n$r$f$a$x$c
  case $e$n$r$f$a$x$c in
     1001010) myex 'ash (Slackware 8.1 ff, dash 0.3.7-11 - 0.3.7-14)'
  ;; 10010??) myex 'ash (dash 0.3-1 - 0.3.7-10, NetBSD 1.2 - 3.1/4.0)'
  ;; 10011*)  myex 'ash (NetBSD 3.1/4.0 ff)'
  ;; 00101*)  myex 'ash (dash 0.5.5.1 ff)'
  ;; 00100*)  myex 'ash (dash 0.5.3-0.5.5)'
  ;;      *)  myex 'unknown ash'
  ;;esac
}

savedbg=$! # save unused $! for a later check

# Korn shell ksh93, $KSH_VERSION not implemented before 93t'
# protected: fatal substitution error in non-ksh
( eval 'test "x${.sh.version}" != x' ) 2>/dev/null &
wait $! && { eval 'PATH=;case $(XtInitialize 2>&1) in Usage*)
    DTKSH=" (dtksh/CDE variant)";;esac
    myex "ksh93 ${.sh.version}${DTKSH}"'; }

# Korn shell ksh86/88
_XPG=1;test "`typeset -Z2 x=0; echo $x`" = '00' && {
  case `print -- 2>&1` in *"bad option"*)
    myex 'ksh86 Version 06/03/86(/a)';; esac
  test "$savedbg" = '0'&& myex 'ksh88 Version (..-)11/16/88 (1st release)'
  test ${x-"{a}"b} = '{ab}' && myex 'ksh88 Version (..-)11/16/88a'
  case "`for i in . .; do echo ${i[@]} ;done 2>&1`" in
    "subscript out of range"*)
    myex 'ksh88 Version (..-)11/16/88b or c' ;; esac
  test "`whence -v true`" = 'true is an exported alias for :' &&
    myex 'ksh88 Version (..-)11/16/88d'
  test "`(cd /dev/null 2>/dev/null; echo $?)`" != '1' &&
    myex 'ksh88 Version (..-)11/16/88e'
  test "`(: $(</file/notexistent); echo x) 2>/dev/null`" = '' &&
    myex 'ksh88 Version (..-)11/16/88f'
   case `([[ "-b" > "-a" ]]) 2>&1` in *"bad number"*) \
    myex 'ksh88 Version (..-)11/16/88g';;esac # fixed in OSR5euc
  test "`cd /dev;cd -P ..;pwd 2>&1`" != '/' &&
    myex 'ksh88 Version (..-)11/16/88g' # fixed in OSR5euc
  test "`f(){ typeset REPLY;echo|read;}; echo dummy|read; f;
     echo $REPLY`" = "" && myex 'ksh88 Version (..-)11/16/88h'
  test $(( 010 )) = 8 &&
    myex 'ksh88 Version (..-)11/16/88i (posix octal base)'
  myex 'ksh88 Version (..-)11/16/88i'
}

echo 'UNKNOWN'
]

}


# FUNCTION
# check_setup: Check system setup (required external programs available?).
check_setup () {	
	
	message="Required program not found or not working as expected: "
	
	# Echo (test first, since the following require a working echo command!)
	prg="${ECHO}"
	result=`"${ECHO}" "1 2 4 3"`
	if [ "$result" != "1 2 4 3" ] ; then
		exit_error "$message ${prg}"
	fi
	
	# The following commands are only tested if they have been defined!
	
	# Awk	
	prg="${AWK}"
	if [ -n "${prg}" ] ; then
		result=`"${ECHO}" "1 2 4 3" | ${prg} '{ print $3 }'`
		if [ $result -ne 4 ] ; then
			exit_error "$message ${prg}"
		fi
	fi
	
	# Cut
	prg="${CUT}"
	if [ -n "${prg}" ] ; then
		result=`"${ECHO}" "1,2,4,3" | ${prg} -f3 -d,`
		if [ $result -ne 4 ] ; then
			exit_error "$message ${prg}"
		fi
	fi
	
	# Date
	prg="${DATE}"
	if [ -n "${prg}" ] ; then
		: $(${prg} -u)
		check_error "${message} '${prg}'."
	fi
	
	# Expr
	prg="${EXPR}"
	if [ -n "${prg}" ] ; then
		result=`${prg} 1 + 3`
		if [ $result -ne 4 ] ; then
			exit_error "$message ${prg}"
		fi
	fi
	
	# Grep
	prg="${GREP}"
	if [ -n "${prg}" ] ; then
		result=`"${ECHO}" "1 2 3 4" | ${prg} "3 4" -c`
		if [ $result -ne 1 ] ; then
			exit_error "$message ${prg}"
		fi
	fi
	
	# Check for multi-threading support.
	# Pkill, Sleep, Wait: Multi-threading support
	if [ -z "${PKILL}" ] || [ -z "${WAIT}" ] || [ -z "${SLEEP}" ] ; then
		# If any of these commands ire missing then we are running on a system (likely Windows)
		# that does not have what it takes for concurrent execution of shell scripts.
		MULTI_THREADING_SUPPORT=
	else
		# In the other case, all three of pkill, wait and sleep must be present!
		#
		# We have pkill command: Let's check that it works!
		# TODO: There seems to be no portable AND safe way of checking
		#       that pkill works. For now, we just trust that it's there
		#		if $PKILL is declared!
		#prg="${PKILL}"
		#: $(${prg} --help)
		#check_error "${message} '${prg}'."
		# We have sleep command: Let's check that it works!
		prg="${SLEEP}"
		: $(${prg} 0.1)
		check_error "${message} '${prg}'."
		# We have wait command: Let's check that it works!
		prg="${WAIT}"
		: $(${prg})
		check_error "${message} '${prg}'."
		# Support for multi-threading exists!
		MULTI_THREADING_SUPPORT="y"
	fi
	
	# Sort
	prg="${SORT}"
	if [ -n "${prg}" ] ; then
		result=`"${ECHO}" "Just one line." | ${prg}`
		check_error "${message} '${prg}'."
	fi
	
	# Wc
	prg="${WC}"
	if [ -n "${prg}" ] ; then	
		result=`"${ECHO}" "one two five" | ${prg} -w`
		if [ $result -ne 3 ] ; then
			exit_error "$message ${prg}"
		fi
	fi
	
}


# FUNCTION
# check_params:		Check parametrization for validity.
#					This is done before any data is produced.
#					So we can use g.message -e/exit here to abort without
#					triggering any clean-ups!
check_params () {
	
	# At least one input map must be provided.
	if [ -z "$GIS_OPT_LINKS" ] && [ -z "$GIS_OPT_NODES" ] ; then
		exit_error "At least one of options 'links=' and 'nodes=' must be specified."
	fi

	# Option 'title="' requires option 'report='.
	if [ -n "$GIS_OPT_TITLE" ] && [ -z "$GIS_OPT_REPORT" ] ; then
		exit_error "Option 'title=' requires option 'report=' to also be specified."
	fi

	# Flag '-a' requires option 'report='.
	if [ ${GIS_FLAG_A} -eq 1 ] ; then
		if [ -z "${GIS_OPT_REPORT}" ] ; then
			exit_error "Flag '-a' is only valid in combination with option 'report='."
		fi
	fi

	# Shell script style output contradicts 'report=' and '-a'.
	if [ ${GIS_FLAG_G} -eq 1 ] ; then
		if [ -n "${GIS_OPT_REPORT}" ] ; then
			exit_error "Flag '-g' cannot be set in combination with option 'report='."
		fi
	fi
}


# FUNCTION
# check_environment: Query GRASS environment for some important variables.
check_environment () {	
	
	# Determine/report shell capabilities
	interpreter=`get_interpreter`
	g.message -i "Running in '$interpreter'."
	is_bash=0
	is_bourne=0
	is_bash=`${ECHO} ${interpreter} |${GREP} "bash" -c`
	is_bourne=`${ECHO} ${interpreter} |${GREP} "Bourne" -c`
	if [ $is_bash -eq 0 ] ; then # We are NOT running in Bash!
		if [ $is_bourne -eq 1 ] ; then # This seems to be the original Bourne shell.
			g.message -w "Running in slow Bourne shell compatibility mode."
			g.message -w "For better performance, try running this script in Bash explicitly."
		else # This seems to be neither Bash nor Bourne.
			g.message -w "Could not assert that the current interpreter is Bash or Bourne shell."
			g.message -w "If this script throws inexplicable errors, try running it in Bash."
			g.message -w "Assuming compatibility with Bash version $BASH_VERSION_MIN."
			BASH_VERSION="$BASH_VERSION_MIN"
		fi
	else # We are running in Bash!
		if [ -z $BASH_VERSION ] ; then
			# If BASH_VERSION has not been set at this point then we just assume a version!
			g.message -w "BASH_VERSION not set. Assuming at least version $BASH_VERSION_MIN."
			BASH_VERSION="$BASH_VERSION_MIN"			
		fi
		# Get Bash major version as currently set.
		bash_version_major=`${ECHO} "$BASH_VERSION" | ${CUT} -f1 -d.`
		g.message -i "Detected Bash version '$bash_version_major'."
		if [ ${bash_version_major} -lt ${BASH_VERSION_MIN} ] ; then
			g.message -w "Bash version is lower than assumed minimal version (${BASH_VERSION_MIN})."
			g.message -w "Expect trouble."
		fi
	fi
	
	# Get essential GRASS environment settings
	GISDBASE=`g.gisenv get=GISDBASE`
	LOCATION_NAME=`g.gisenv get=LOCATION_NAME`
	MAPSET=`g.gisenv get=MAPSET`
	
	# Set GRASS verbosity (no --q or --v given):
	if [ -z "$GRASS_VERBOSE" ] ; then
		GRASS_VERBOSE=1
	fi
	
	# Get current region settings.
	eval `g.region -p -g`	

	# Store projection (to differentiate x/y and lat/lon)
	GRASS_REG_PROJECTION="${projection}"
	if [ "${GRASS_REG_PROJECTION}" = "3" ] ; then
		if [ ${GRASS_VERBOSE} -gt 0 ] ; then
			g.message -w "Running in lat/lon mode. Expect reduced performance."
		fi
	fi

	# Get current GRASS database connection	
	cmd=`db.connect -pg`
	check_error "Failed to query GRASS session for current database connection ('db.connect')."
	eval_ws_safe "${cmd}" "driver"
	GRASS_DB_driver="${EVAL_RESULT}"
	eval_ws_safe "${cmd}" "database"
	GRASS_DB_database="${EVAL_RESULT}"
	
	# Ensure that we are running with a supported DBMS!
	# A supported DBMS must have sufficient SQL capabilities for this script's attribute data
	# operations.
	DBMS_SUPPORTED=0
	DBMS_NAME="unsupported"
	# SQLite: Sufficient SQL capabilities, but not thread-safe with default setup
	# (=one SQLite database per mapset).
	if [ "${GRASS_DB_driver}" = "sqlite" ] ; then
		DBMS_SUPPORTED=1
		DBMS_NAME="SQLite"		
		DBMS_INDEX_SUPPORTED=1
		DBMS_PRESERVES_ORDER=1
		DBMS_IDENT_QUOTE="'"
		# It is possible to force the SQLite backend driver to use one
		# DB per vector map instead of one DB per mapset.
		result=`"${ECHO}" "$GRASS_DB_database" | "${GREP}" '/vector/$MAP/' -c`
		if [ ${result} -gt 0 ] ; then
			DBMS_THREAD_SAFE=1
			if [ ${GRASS_VERBOSE} -gt 0 ] ; then
				g.message -w "SQLite backend appears to be in per-map mode. Expect errors."
			fi
		else
			if [ ${GRASS_VERBOSE} -gt 2 ] ; then
				g.message -i "SQLite backend appears to be in default mode (single database)."
			fi
		fi
		DBMS_FILE_PATH=1
	fi
	# PostgreSQL: Full SQL capabilities and thread safe
	if [ "${GRASS_DB_driver}" = "pg" ] ; then
		DBMS_SUPPORTED=1
		DBMS_NAME="PostgreSQL"
		DBMS_THREAD_SAFE=1
		DBMS_INDEX_SUPPORTED=1
		DBMS_PRESERVES_ORDER=0
		DBMS_IDENT_QUOTE='"'
	fi
	# MySQL/MariaDB: Full SQL capabilities and thread safe
	if [ "${GRASS_DB_driver}" = "mysql" ] ; then
		if [ ${GRASS_VERBOSE} -gt 0 ] ; then
			g.message -w "MySQL/MariaDB used: Use input data with minimal number of attribute fields to avoid storage size errors."
		fi
		DBMS_SUPPORTED=1
		DBMS_NAME="MySQL/MariaDB"		
		DBMS_THREAD_SAFE=1
		DBMS_INDEX_SUPPORTED=1
		DBMS_PRESERVES_ORDER=1
		DBMS_IDENT_QUOTE='`'
	fi
	# Embedded version of MySQL/MariaDB: Full SQL capabilities and thread safe
	if [ "${GRASS_DB_driver}" = "mesql" ] ; then
		DBMS_SUPPORTED=1
		DBMS_NAME="MySQL/MariaDB (embedded)"
		DBMS_THREAD_SAFE=1
		DBMS_INDEX_SUPPORTED=1
		DBMS_PRESERVES_ORDER=1
		DBMS_IDENT_QUOTE='`'
	fi
	if [ ${DBMS_SUPPORTED} -lt 1 ] ; then
		exit_error "Current mapset does not use a known DBMS."
	fi

	if [ ${GRASS_VERBOSE} -gt 2 ] ; then
		g.message -i "Running with DBMS driver '${GRASS_DB_driver}' (${DBMS_NAME})."
	fi
}


# FUNCTION
# get_primary_keys: Build array of primary key values (from field chosen via 'key=' option).
#                   FUNCTION check_input MUST RUN FIRST to validate GIS_OPT_KEY!!!
#					 The only argument for this function ($1) is the name of the GRASS vector
#                   map from which to gather the keys.
#					 The name of the primary key field is read from $GIS_OPT_KEY.
#                   Primary keys are returned in array PRIMARY_KEYS.
#                   This function will abort the program if it encounters any errors!
get_primary_keys () {
	PRIMARY_KEYS=`v.db.select map="$1" columns="${GIS_OPT_KEY}" -c --quiet`
	check_error "Failed to retrieve primary keys (map='$1')."
}


# FUNCTION
# get_grass_cats:	Build array of all GRASS internal primary key values for map in $1.
#					Normally, these keys are in the 'cats' column, but this is customizable,
#					so this function makes sure to get the correct column name from the
#					map's metadata first.
#                 	The only argument for this function ($1) is the name of the GRASS vector
#                  	map from which to gather the keys.
#                 	Primary keys are returned in array GRASS_CATS.
#					Name of GRASS primary key column for map '$1' is returned in variable GRASS_PKEY. 
#                 	This function will abort the program if it encounters any errors!
get_grass_cats () {
	cmd=`v.info -e map="$1"`
	check_error "Failed to query vector map '$1' for extended metadata."
	eval_ws_safe "${cmd}" "attribute_primary_key"
	if [ -z "${EVAL_RESULT}" ] ; then
		exit_error "Failed to retrieve name of GRASS primary key column for vector map '$1'."
	fi
	GRASS_CATS=`v.db.select map="$1" columns="${EVAL_RESULT}" -c --quiet`
	GRASS_PKEY="${EVAL_RESULT}"
	check_error "Failed to retrieve list of GRASS primary keys (map='$1')."
}


# FUNCTION
# get_tbl_info: Retrieves essential information for first attribute table's DB connection
#				("layer 1") connected to a GRASS vector map. The information is read from
#				the output of 'v.info'.
#
#            	This function reads one argument:
#					$1 -- name of GRASS vector map that has the attibute table of interest
#
#            	This function sets three variables:
#               	attribute_database_driver = GRASS database driver used for the connection
#												(same as used/listed by 'db.connect')
#					attribute_database = the name of the actual DB that stores the table
#					attribute_table = the name of the linked attribute table in the DB
#
#				 It will abort the program if there is a problem with the map and/or its table.            
#
get_tbl_info () {
	cmd=`v.info -e map="${1}" layer="1"`
	check_error "Failed to query vector map '$1' for extended metadata."
	
	# Get DB driver name:
	eval_ws_safe "${cmd}" "attribute_database_driver"
	if [ -z "${EVAL_RESULT}" ] ; then
		exit_error "Failed to retrieve driver of database connection for vector map '1'."
	fi
	attribute_database_driver="${EVAL_RESULT}"
	
	# Get name of connected database:
	eval_ws_safe "${cmd}" "attribute_database"
	if [ -z "${EVAL_RESULT}" ] ; then
		exit_error "Failed to retrieve name of database connection for vector map '$1'."
	fi
	attribute_database="${EVAL_RESULT}"
	
	# Get name of linked table in conntected DB:
	eval_ws_safe "${cmd}" "attribute_table"
	if [ -z "${EVAL_RESULT}" ] ; then
		exit_error "Failed to retrieve name of database table for vector map '1'."
	fi
	attribute_table="${EVAL_RESULT}"
}


# FUNCTION
# get_where_clause:		Composes an SQL 'where' clause to be used in a "where=" option
#						of a GRASS module. The clause can be used to retrieve the feature
#						that matches the value of the primary key passed in $1.
#						This function will take care that field names and values are
#						properly quoted, the latter depending on the type of the primary
#						key.
#						The name of the primary key is read from ${GIS_OPT_KEY}.
#						The resulting clause will be written into the variable WHERE.
#
get_where_clause () {
	WHERE="${GIS_OPT_KEY}=$1"
}


# FUNCTION
# stats_compute_links: 	Computes statistics for network links (to be printed later).
#
stats_compute_links () {
	# Get attribute table info for output links map:
	get_tbl_info "${GIS_OPT_LINKS}"
	attribute_database_driver_links="$attribute_database_driver"
	attribute_database_links="$attribute_database"
	attribute_table_links="$attribute_table"
	# Get global statistics for unreduced network.
	# We will output these at the end of the program run!
	if [ ${GRASS_VERBOSE} -gt 0 ] ; then
		g.message -i "Computing statistics for network links:"
	fi
	eval `v.info -t map="${GIS_OPT_LINKS}" layer="1"`
	get_grass_cats "${GIS_OPT_LINKS}"	
	total_cost=0
	total_len=0
	# min/max initially empty strings
	min_len=""
	max_len=""
	min_cost=""
	max_cost=""
	step=1 # This one is just for progress reporting.
	# Compute simple metrics
	OLD_IFS="$IFS"
	IFS="${IFS_NEWLINE}"
	for cat in ${GRASS_CATS} ; do
		len=`db.select sql="SELECT ${LINKS_FLD_LEN_M} FROM ${attribute_table_links} WHERE ${GRASS_PKEY}=${cat};" database="$attribute_database_links" driver="$attribute_database_driver_links" -c --quiet`
		check_error "Failed to query field '${LINKS_FLD_LEN_M}' from links output layer (${GRASS_PKEY}='${cat}')"
		awk_min "${min_len}" "${len}"
		min_len="${AWK_VALUE}"
		awk_max "${max_len}" "${len}"
		max_len="${AWK_VALUE}"
		awk_calc "$total_len+$len"
		total_len="${AWK_VALUE}"
		if [ "${RUNMODE_COST}" == "TRUE" ] ; then
			cost=`db.select sql="SELECT ${LINKS_FLD_COST} FROM ${attribute_table_links} WHERE ${GRASS_PKEY}=${cat};" database="$attribute_database_links" driver="$attribute_database_driver_links" -c --quiet`
			check_error "Failed to query field '${LINKS_FLD_COST}' from links output layer (${GRASS_PKEY}='${cat}')"
			awk_min "${min_cost}" "${cost}"
			min_cost="${AWK_VALUE}"
			awk_max "${max_cost}" "${cost}"
			max_cost="${AWK_VALUE}"			
			awk_calc "$total_cost+$cost"
			total_cost="${AWK_VALUE}"
		fi
		if [ ${GRASS_VERBOSE} -gt 0 ] ; then
			g.message -p "${step} ${lines} 1"
		fi
		if [ -n $BASH_VERSION ] ; then
			let step=${step}+1
		else
			step=`"${EXPR}" ${step} + 1`
		fi		
	done
	IFS="${OLD_IFS}"
	net_nodes_undreduced="${NUM_INPUT_NODES}"
	net_links_unreduced="${lines}"
	net_len_unreduced="${total_len}"
	net_len_min_unreduced="${min_len}"
	net_len_max_unreduced="${max_len}"
	if [ "${RUNMODE_COST}" == "TRUE" ] ; then
		net_cost_unreduced="${total_cost}"
		net_cost_min_unreduced="${min_cost}"
		net_cost_max_unreduced="${max_cost}"
		net_cost_max_unreduced="${max_cost}"
	fi
	# Compute means
	awk_calc "(($lines*2)/$NUM_INPUT_NODES)" # 1 link = 2 connections (one at each end!)
	net_cons_mean_unreduced="${AWK_VALUE}"
	awk_calc "$total_len/$lines"
	net_len_mean_unreduced="${AWK_VALUE}"
	if [ "${RUNMODE_COST}" == "TRUE" ] ; then
		awk_calc "$total_cost/$lines"
		net_cost_mean_unreduced="${AWK_VALUE}"
	fi
	# Compute median(s)
	lengths=`v.db.select map="${GIS_OPT_LINKS}" layer="1" columns="${LINKS_FLD_LEN_M}" -c`
	check_error "Failed to query field '${LINKS_FLD_LEN_M}' from links output layer (${GIS_OPT_LINKS})."
	awk_median "$lengths"	
	if [ -z "${AWK_VALUE}" ] ; then
		exit_error "No length data found in attribute table of links output layer (${GIS_OPT_LINKS})."
	fi
	net_len_median_unreduced="${AWK_VALUE}"
	if [ "${RUNMODE_COST}" == "TRUE" ] ; then
		costs=`v.db.select map="${GIS_OPT_LINKS}" layer="1" columns="${LINKS_FLD_COST}" -c`
		check_error "Failed to query field '${LINKS_FLD_COST}' from links output layer (${GIS_OPT_LINKS})."
		awk_median "$costs"	
		if [ -z "${AWK_VALUE}" ] ; then
			exit_error "No cost data found in attribute table of links output layer (${GIS_OPT_LINKS})."
		fi
		net_cost_median_unreduced="${AWK_VALUE}"
	fi
}


# FUNCTION
# stats_compute_nodes: 	Computes statistics for network nodes (to be stored in nodes input map attributes).
#
stats_compute_nodes () {
	# Get and store attribute table info for output maps:
	# Get attribute table info:
		get_tbl_info "${GIS_OPT_LINKS}"
		attribute_database_driver_links="$attribute_database_driver"
		attribute_database_links="$attribute_database"
		attribute_table_links="$attribute_table"
		get_tbl_info "${GIS_OPT_NODES}"
		attribute_database_driver_nodes="$attribute_database_driver"
		attribute_database_nodes="$attribute_database"
		attribute_table_nodes="$attribute_table"

	if [ ${GRASS_VERBOSE} -gt 0 ] ; then
		g.message -i "Computing statistics for network nodes:"
	fi
	eval `v.info -t map="${GIS_OPT_NODES}" layer="1"`
	# Start looping through nodes by user-defined key
	get_primary_keys "${GIS_OPT_NODES}"
	step=1 # For progress reporting
	OLD_IFS="$IFS"
	IFS="${IFS_NEWLINE}"
	for key in ${PRIMARY_KEYS} ; do	
		# Number of other nodes wo which the current node is connected:
		num_links=`db.select database="${attribute_database_links}" sql="SELECT * FROM ${attribute_table_links} WHERE $LINKS_FLD_FROM_ID=$key OR $LINKS_FLD_TO_ID=$key;" driver="$attribute_database_driver_links" -c --quiet | "${GREP}" "${key}" -c`
		# Lengths of all from/to links to the current node:
		len=`db.select database="${attribute_database_links}" sql="SELECT ${LINKS_FLD_LEN_M} FROM ${attribute_table_links} WHERE $LINKS_FLD_FROM_ID=$key OR $LINKS_FLD_TO_ID=$key;" driver="$attribute_database_driver_links" -c --quiet`
		if [ "${RUNMODE_COST}" == "TRUE" ] ; then
			cost=`db.select database="${attribute_database_links}" sql="SELECT ${LINKS_FLD_COST} FROM ${attribute_table_links} WHERE $LINKS_FLD_FROM_ID=$key OR $LINKS_FLD_TO_ID=$key;" driver="$attribute_database_driver_links" -c --quiet`
		fi
		# Compute total and mean statistics
		total_len=0
		total_cost=0
		avg_len=0
		avg_cost=0
		for i in $len ; do
			awk_calc "$total_len+$i"
			total_len="${AWK_VALUE}"
		done
		if [ $num_links -gt 0 ] ; then
			awk_calc "$total_len/$num_links"
			avg_len="${AWK_VALUE}"
		fi
		if [ "${RUNMODE_COST}" == "TRUE" ] ; then
			for i in $cost ; do
				awk_calc "$total_cost+$i"
				total_cost="${AWK_VALUE}"
			done
			if [ $num_links -gt 0 ] ; then
				awk_calc "$total_cost/$num_links"
				avg_cost="${AWK_VALUE}"
			fi
		fi
		# Upload statistics fields to current node:
		get_where_clause "${key}"
		# Initialize contents of first SQL_CHUNK to 'empty':
		SQL_CHUNK="${DBMS_BEGIN}"
		# Update attribute table fields:
		SQL=""
		SQL="${SQL}UPDATE ${attribute_table_nodes} SET"
		SQL="${SQL} ${NODES_FLD_LINKS} = ${num_links}"
		SQL="${SQL} WHERE ${WHERE}; "
		SQL_CHUNK="${SQL_CHUNK}
${SQL}"
		if [ "${GIS_OPT_MODEL}" = "attsim" ] ; then
			SQL=""
			SQL="${SQL}UPDATE ${attribute_table_nodes} SET"
			SQL="${SQL} ${NODES_FLD_NSTRENGTH} = ${n_strength}"
			SQL="${SQL} WHERE ${WHERE}; "
			SQL_CHUNK="${SQL_CHUNK}
${SQL}"
		fi
		SQL=""
		SQL="${SQL}UPDATE ${attribute_table_nodes} SET"
		SQL="${SQL} ${NODES_FLD_LEN_SUM} = ${total_len}"
		SQL="${SQL} WHERE ${WHERE}; "
		SQL_CHUNK="${SQL_CHUNK}
${SQL}"
		SQL=""
		SQL="${SQL}UPDATE ${attribute_table_nodes} SET"
		SQL="${SQL} ${NODES_FLD_LEN_AVG} = ${avg_len}"
		SQL="${SQL} WHERE ${WHERE}; "
		SQL_CHUNK="${SQL_CHUNK}
${SQL}"
		if [ "${RUNMODE_COST}" == "TRUE" ] ; then
			SQL=""
			SQL="${SQL}UPDATE ${attribute_table_nodes} SET"
			SQL="${SQL} ${NODES_FLD_COST_SUM} = ${total_cost}"
			SQL="${SQL} WHERE ${WHERE}; "
			SQL_CHUNK="${SQL_CHUNK}
${SQL}"
			check_error "Failed to write links count into attribute field '${NODES_FLD_COST_SUM}' of output nodes maps ('${GIS_OPT_NODES}')."
			SQL=""
			SQL="${SQL}UPDATE ${attribute_table_nodes} SET"
			SQL="${SQL} ${NODES_FLD_COST_AVG} = ${avg_cost}"
			SQL="${SQL} WHERE ${WHERE}; "
			SQL_CHUNK="${SQL_CHUNK}
${SQL}"
		fi
		# Commit transaction of SQL chunk:
		SQL_CHUNK="${SQL_CHUNK}
${DBMS_COMMIT}"
		"${ECHO}" "${SQL_CHUNK}" | db.execute driver="$attribute_database_driver_nodes" database="${attribute_database_nodes}" input="-"
		check_error "Failed to write all attribute fields of record #${key} into output nodes maps ('${GIS_OPT_NODES}')."

		g.message -p "${step} ${points} 1"
		if [ -n $BASH_VERSION ] ; then
			let step=${step}+1
		else
			step=`"${EXPR}" ${step} + 1`
		fi
	done
	IFS="${OLD_IFS}"
}


# FUNCTION
# MAIN():	This is a bogus function. It exists only so that text
#			editors will find this as a mark when parsing the source
#		   	code in SH mode, and it will be added to the document outline. 
MAIN () {
	"${ECHO}" ""
}


########
# MAIN #
########

# Keep track of starting time.
START=`"${DATE}"`

# Check GRASS environment:
check_environment

# Go!
if [ ${GRASS_VERBOSE} -gt 2 ] ; then
	g.message -i "$MODULE_NAME_EXEC ($MODULE_VERSION) started."
fi

# Run all pre-flight checks:
check_setup
check_params
check_input

# GO! GO!

get_grass_cats "${GIS_OPT_LINKS}"
stats_compute_links
stats_compute_nodes

# Output basic network statistics
if [ ${GIS_FLAG_G} -eq 1 ] ; then
	# Terse output to console
	"${ECHO}" "net_nodes_unreduced=${net_nodes_undreduced}"
	"${ECHO}" "net_links_unreduced=${net_links_unreduced}"	
	"${ECHO}" "net_len_unreduced=${net_len_unreduced}"
	if [ "${RUNMODE_COST}" == "TRUE" ] ; then
		"${ECHO}" "net_cost_unreduced=${net_cost_unreduced}"
	fi
	"${ECHO}" "net_cons_mean_unreduced=${net_cons_mean_unreduced}"
	"${ECHO}" "net_len_min_unreduced=${net_len_min_unreduced}"
	"${ECHO}" "net_len_max_unreduced=${net_len_max_unreduced}"	
	"${ECHO}" "net_len_mean_unreduced=${net_len_mean_unreduced}"
	"${ECHO}" "net_len_median_unreduced=${net_len_median_unreduced}"
	if [ "${RUNMODE_COST}" == "TRUE" ] ; then
		"${ECHO}" "net_cost_min_unreduced=${net_cost_min_unreduced}"
		"${ECHO}" "net_cost_max_unreduced=${net_cost_max_unreduced}"
		"${ECHO}" "net_cost_mean_unreduced=${net_cost_mean_unreduced}"
		"${ECHO}" "net_cost_median_unreduced=${net_cost_median_unreduced}"
	fi
else
	if [ -n "${GIS_OPT_REPORT}" ] ; then
		# Detailed output to file.
		#		
		# HEADER (1)
		if [ ${GIS_FLAG_A} -eq 1 ] ; then
			"${ECHO}" "$MODULE_NAME_EXEC $MODULE_VERSION" >> "${GIS_OPT_REPORT}"
		else
			"${ECHO}" "$MODULE_NAME_EXEC $MODULE_VERSION" > "${GIS_OPT_REPORT}"
		fi
		# ADDITIONAL TITLE STRING (if given)
		if [ -n "${GIS_OPT_TITLE}" ] ; then
			"${ECHO}" "=======================================" >> "${GIS_OPT_REPORT}"
			"${ECHO}" "${GIS_OPT_TITLE}" >> "${GIS_OPT_REPORT}"
		fi
		# HEADER (2)
		"${ECHO}" "Started  : ${START}" >> "${GIS_OPT_REPORT}"
		END=`"${DATE}"`
		"${ECHO}" "Completed: ${END}" >> "${GIS_OPT_REPORT}"
		"${ECHO}" "Parameters:" >> "${GIS_OPT_REPORT}"
		"${ECHO}" "    Links = ${GIS_OPT_LINKS}" >> "${GIS_OPT_REPORT}"
		"${ECHO}" "    Nodes = ${GIS_OPT_NODES_ORG}" >> "${GIS_OPT_REPORT}"
		"${ECHO}" "    key   = ${GIS_OPT_KEY}" >> "${GIS_OPT_REPORT}"
		"${ECHO}" "=======================================" >> "${GIS_OPT_REPORT}"
		# STATS			
		"${ECHO}" "Network properties:" >> "${GIS_OPT_REPORT}"
		"${ECHO}" "Nodes: ${net_nodes_undreduced}" >> "${GIS_OPT_REPORT}"
		"${ECHO}" "Links: ${net_links_unreduced}" >> "${GIS_OPT_REPORT}"
		"${ECHO}" "Total network length(m): ${net_len_unreduced}" >> "${GIS_OPT_REPORT}"
		if [ "${RUNMODE_COST}" == "TRUE" ] ; then
			"${ECHO}" "Total network cost: ${net_cost_unreduced}" >> "${GIS_OPT_REPORT}"
		fi		
		"${ECHO}" "Mean connections/node: ${net_cons_mean_unreduced}" >> "${GIS_OPT_REPORT}"
		"${ECHO}" "Min. link length: ${net_len_min_unreduced}" >> "${GIS_OPT_REPORT}"
		"${ECHO}" "Max. link length: ${net_len_max_unreduced}" >> "${GIS_OPT_REPORT}"
		"${ECHO}" "Mean link length: ${net_len_mean_unreduced}" >> "${GIS_OPT_REPORT}"
		"${ECHO}" "Median link length: ${net_len_median_unreduced}" >> "${GIS_OPT_REPORT}"	
		if [ "${RUNMODE_COST}" == "TRUE" ] ; then
			"${ECHO}" "Min. link cost: ${net_cost_min_unreduced}" >> "${GIS_OPT_REPORT}"
			"${ECHO}" "Max. link cost: ${net_cost_max_unreduced}" >> "${GIS_OPT_REPORT}"
			"${ECHO}" "Mean link cost: ${net_cost_mean_unreduced}" >> "${GIS_OPT_REPORT}"
			"${ECHO}" "Median link cost: ${net_cost_median_unreduced}" >> "${GIS_OPT_REPORT}"
		fi
		# FOOTER
		"${ECHO}" " " >> "${GIS_OPT_REPORT}"
	else
		# Detailed output to console.
		g.message -i "Network properties:"
		g.message -i "Nodes: ${net_nodes_undreduced}"
		g.message -i "Links: ${net_links_unreduced}"
		g.message -i "Total network length(m): ${net_len_unreduced}"
		if [ "${RUNMODE_COST}" == "TRUE" ] ; then
			g.message -i "Total network cost: ${net_cost_unreduced}"
		fi		
		g.message -i "Mean connections/node: ${net_cons_mean_unreduced}"
		g.message -i "Min. link length: ${net_len_min_unreduced}"
		g.message -i "Max. link length: ${net_len_max_unreduced}"
		g.message -i "Mean link length: ${net_len_mean_unreduced}"
		g.message -i "Median link length: ${net_len_median_unreduced}"	
		if [ "${RUNMODE_COST}" == "TRUE" ] ; then
			g.message -i "Min. link cost: ${net_cost_min_unreduced}"
			g.message -i "Max. link cost: ${net_cost_max_unreduced}"
			g.message -i "Mean link cost: ${net_cost_mean_unreduced}"
			g.message -i "Median link cost: ${net_cost_median_unreduced}"
		fi
	fi
fi


# DONE!

# Remove temp. maps, restore region, etc.
clean_up

# Show processing time.
if [ ${GRASS_VERBOSE} -gt 2 ] ; then
	g.message -i "Success."
	g.message -i "Started: ${START}"
	END=`"${DATE}"`
	g.message -i "Completed: ${END}"
fi

# Exit with status "OK"
exit ${EXIT_OK}
